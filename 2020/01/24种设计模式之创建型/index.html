<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.57.2 with theme Tranquilpeak 0.4.7-BETA">
<meta name="author" content="轲">
<meta name="keywords" content="设计模式, C#, .NET, 个人博客">
<meta name="description" content="24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。">


<meta property="og:description" content="24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="24种设计模式之创建型">
<meta name="twitter:title" content="24种设计模式之创建型">
<meta property="og:url" content="https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
<meta property="twitter:url" content="https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
<meta property="og:site_name" content="轲的大风歌">
<meta property="og:description" content="24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。">
<meta name="twitter:description" content="24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2020-01-02T10:16:54">
  
  
    <meta property="article:modified_time" content="2020-01-02T10:16:54">
  
  
  
    
      <meta property="article:section" content="设计模式">
    
  
  
    
      <meta property="article:tag" content="设计模式">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://SLTaurus.github.io/images/cover.jpg">
  <meta property="twitter:image" content="https://SLTaurus.github.io/images/cover.jpg">


  <meta property="og:image" content="https://SLTaurus.github.io/images/cover.jpg">
  <meta property="twitter:image" content="https://SLTaurus.github.io/images/cover.jpg">




  <meta property="og:image" content="https://SLTaurus.github.io/images/touxiang.jpg">
  <meta property="twitter:image" content="https://SLTaurus.github.io/images/touxiang.jpg">


    <title>24种设计模式之创建型</title>

    <link rel="icon" href="https://SLTaurus.github.io/favicon.jpg">
    

    

    <link rel="canonical" href="https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://SLTaurus.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://SLTaurus.github.io/">轲的大风歌</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://SLTaurus.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://SLTaurus.github.io/images/touxiang.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://SLTaurus.github.io/#about">
          <img class="sidebar-profile-picture" src="https://SLTaurus.github.io/images/touxiang.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">轲</h4>
        
          <h5 class="sidebar-profile-bio">作为一个好的程序员，一定要有执着钻研、刻苦学习、认真仔细和精益求精的朴素品质。</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">类别</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/SLTaurus" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-center
              post-header-cover--full"
       style="background-image:url('/images/cover.jpg')"
       data-behavior="5">
    
  </div>


      <div id="main" data-behavior="5"
        class="hasCover
               hasCoverMetaOut
               hasCoverCaption">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
            <span class="post-header-cover-caption caption">24种设计模式</span>
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title" itemprop="headline">
      24种设计模式之创建型
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2020-01-02T10:16:54&#43;08:00">
        
  一月 2, 2020

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://SLTaurus.github.io/categories/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">设计模式</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。</p>

<h1 id="table-of-contents">目录</h1><nav id="TableOfContents">
<ul>
<li><a href="#创建型">创建型</a>
<ul>
<li><a href="#01-简单工厂模式">01-简单工厂模式</a>
<ul>
<li><a href="#uml图">UML图</a></li>
<li><a href="#优点-缺点和适用环境">优点、缺点和适用环境</a></li>
<li><a href="#类实例代码">类实例代码</a></li>
<li><a href="#客户端代码">客户端代码</a></li>
</ul></li>
<li><a href="#08-工厂方法模式">08-工厂方法模式</a>
<ul>
<li><a href="#uml类图">UML类图</a></li>
<li><a href="#优点-缺点和应用场景">优点、缺点和应用场景</a></li>
<li><a href="#类实例代码-1">类实例代码</a></li>
<li><a href="#客户端代码-1">客户端代码</a></li>
</ul></li>
<li><a href="#09-原型模式">09-原型模式</a>
<ul>
<li>
<ul>
<li><a href="#使用场景">使用场景</a></li>
</ul></li>
<li><a href="#类实例代码-2">类实例代码</a></li>
<li><a href="#客户端代码-2">客户端代码</a></li>
</ul></li>
<li><a href="#13-建造者模式">13-建造者模式</a>
<ul>
<li><a href="#uml图-1">UML图</a></li>
<li><a href="#优点-缺点和应用场景-1">优点、缺点和应用场景</a></li>
<li><a href="#类实例代码-3">类实例代码</a></li>
<li><a href="#客户端代码-3">客户端代码</a></li>
</ul></li>
<li><a href="#15-抽象工厂模式">15-抽象工厂模式</a>
<ul>
<li><a href="#uml图-2">UML图</a></li>
<li><a href="#类实例代码-4">类实例代码</a></li>
<li><a href="#客户端代码-4">客户端代码</a></li>
</ul></li>
<li><a href="#21-单例模式">21-单例模式</a>
<ul>
<li><a href="#单例实例代码">单例实例代码</a></li>
<li><a href="#多线程时的单例">多线程时的单例</a>
<ul>
<li><a href="#双重锁定">双重锁定</a></li>
<li><a href="#静态初始化">静态初始化</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>

<h1 id="创建型">创建型</h1>

<p>所有工厂都是用来封装对象的创建。</p>

<p>简单工厂提供给我们更多的是一种想法，让我们萌生了将系统做一些分隔的想法，比如将对象的使用和实现进行解耦，等等。</p>

<p>工厂方法使用的是继承和多态，把对象的创建委托给子类。</p>

<p>抽象工厂使用的是对象的组合。对象的创建被实现在工厂接口所暴露的方法中来，比如Pizza类就实现工厂方法模式，里面的Prepare就是一个工厂方法。</p>

<p>所有工厂模式都是通过减少应用程序和类之间的依赖促进耦合。依赖倒置原则，指导我们要尽量避免依赖具体，而要依赖抽象。工厂是很有威力的技巧，帮我们尽量针对接口编程，而不是针对具体。</p>

<h2 id="01-简单工厂模式">01-简单工厂模式</h2>

<p>工厂模式：简单工厂、工厂方法、抽象工厂三种。工厂即为生产东西的地方，在C#也有这种模式，充分利用了面向对象语言的三大特征（多态,继承）。</p>

<p>简单工厂，工厂的功能就是生产，而生产些什么呢？一个工厂可以生产鞋子、生产衣服.它们所处的车间不一样，所以需要两个不同的类，这两个类继承工厂生产这个功能。</p>

<p>简单工厂(力求简洁)，之所以成为简单，即这个工厂所生产的东西是有限的、固定的，因为它只有鞋子、衣服是具体的。</p>

<h3 id="uml图">UML图</h3>

<p><img src="https://SLTaurus.github.io/images/Pattern/SimpleFactory.png" alt="SimpleFactory" /></p>

<ul>
<li>Factory：工厂类，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>IProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li>
<li>Product：具体产品类，是简单工厂模式的创建目标。</li>
</ul>

<h3 id="优点-缺点和适用环境">优点、缺点和适用环境</h3>

<p>优点:</p>

<ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>

<p>缺点：</p>

<ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，同样破坏了“开闭原则”；在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>

<p>适用环境：</p>

<ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>

<h3 id="类实例代码">类实例代码</h3>

<p>代码如下：</p>

<pre><code>/// &lt;summary&gt;
/// 运算类
/// &lt;/summary&gt;
public class SfOperation
{
    private double _numberA = 0;
    private double _numberB = 0;

    /// &lt;summary&gt;
    /// 数字A
    /// &lt;/summary&gt;
    public double NumberA
    {
        get {return _numberA; }
        set{_numberA = value; }
    }

    /// &lt;summary&gt;
    /// 数字B
    /// &lt;/summary&gt;
    public double NumberB
    {
        get { return _numberB; }
        set { _numberB = value; }
    }

    /// &lt;summary&gt;
    /// 得到运算结果
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public virtual double GetResult()
    {
        double result = 0;
        return result;
    }

    /// &lt;summary&gt;
    /// 检查输入字符串是否准确
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;currentNumber&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;inputString&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static string checkNumberInput(string currentNumber, string inputString)
    {
        string result = &quot;&quot;;
        if (inputString == &quot;.&quot;)
        {
            if (currentNumber.IndexOf(&quot;.&quot;) &lt; 0)
            {
                if (currentNumber.Length == 0)
                    result = &quot;0&quot; + inputString;
                else
                    result = currentNumber + inputString;
            }
        }
        else if (currentNumber == &quot;0&quot;)
        {
            result = inputString;
        }
        else
        {
            result = currentNumber + inputString;
        }
        return result;
    }
}

#region 运算类
/// &lt;summary&gt;
/// 运算加
/// &lt;/summary&gt;
public class SfOperationAdd : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA + NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 运算减
/// &lt;/summary&gt;
public class SfOperationSub : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA - NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 运算乘
/// &lt;/summary&gt;
public class SfOperationMul : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA * NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 运算除
/// &lt;/summary&gt;
public class SfOperationDiv : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        if (NumberB == 0)
            throw new Exception(&quot;除数不能为0。&quot;);
        result = NumberA / NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 运算平方
/// &lt;/summary&gt;
public class SfOperationSqr : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberB * NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 运算平方根
/// &lt;/summary&gt;
public class SfOperationSqrt : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        if (NumberB &lt; 0)
            throw new Exception(&quot;负数不能开平方根。&quot;);
        result = Math.Sqrt(NumberB);
        return result;
    }
}

/// &lt;summary&gt;
/// 运算相反数
/// &lt;/summary&gt;
public class SfOperationReverse : SfOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = -NumberB;
        return result;
    }
}
#endregion

/// &lt;summary&gt;
/// 运算类工厂
/// &lt;/summary&gt;
public class SfOperationFactory
{
    public static SfOperation createOperate(string operate)
    {
        SfOperation oper = null;
        switch (operate)
        {
            case &quot;+&quot;:
                {
                    oper = new SfOperationAdd();
                    break;
                }
            case &quot;-&quot;:
                {
                    oper = new SfOperationSub();
                    break;
                }
            case &quot;*&quot;:
                {
                    oper = new SfOperationMul();
                    break;
                }
            case &quot;/&quot;:
                {
                    oper = new SfOperationDiv();
                    break;
                }
            case &quot;sqr&quot;:
                {
                    oper = new SfOperationSqr();
                    break;
                }
            case &quot;sqrt&quot;:
                {
                    oper = new SfOperationSqrt();
                    break;
                }
            case &quot;+/-&quot;:
                {
                    oper = new SfOperationReverse();
                    break;
                }
        }
        return oper;
    }
}
</code></pre>

<h3 id="客户端代码">客户端代码</h3>

<p>代码如下：</p>

<pre><code>public void SimpleFactoryDemo()
    {
        try
        {
            Console.Write(&quot;请输入数字A：&quot;);
            string strNumberA = Console.ReadLine();
            Console.Write(&quot;请选择运算符号(+、-、*、/)：&quot;);
            string strOperate = Console.ReadLine();
            Console.Write(&quot;请输入数字B：&quot;);
            string strNumberB = Console.ReadLine();
            string strResult = &quot;&quot;;

            SfOperation oper;
            oper = SfOperationFactory.createOperate(strOperate);
            oper.NumberA = Convert.ToDouble(strNumberA);
            oper.NumberB = Convert.ToDouble(strNumberB);
            strResult = oper.GetResult().ToString();

            Console.WriteLine(&quot;结果是：&quot; + strResult);
            Console.ReadLine();
        }
        catch (Exception ex)
        {
            Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message);
        }
}   
</code></pre>

<h2 id="08-工厂方法模式">08-工厂方法模式</h2>

<p>定义：工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</p>

<p>主要作用：将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。</p>

<p>解决的问题：
+ 工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则，即简单工厂模式的缺点。
+ 之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点。</p>

<h3 id="uml类图">UML类图</h3>

<p><img src="https://SLTaurus.github.io/images/Pattern/FactoryMethod.png" alt="FactoryMethod" /></p>

<h3 id="优点-缺点和应用场景">优点、缺点和应用场景</h3>

<p>优点：</p>

<ul>
<li>更符合开-闭原则，新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可。而简单工厂模式需要修改工厂类的判断逻辑；</li>
<li>符合单一职责原则，每个具体工厂类只负责创建对应的产品。简单工厂中的工厂类存在复杂的switch逻辑判断；
+不使用静态工厂方法，可以形成基于继承的等级结构。简单工厂模式的工厂类使用静态工厂方法；</li>
</ul>

<p>总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p>

<p>缺点：</p>

<ul>
<li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度；</li>
<li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
<li>一个具体工厂只能创建一种具体产品；</li>
</ul>

<p>应用场景：</p>

<ul>
<li>当一个类不知道它所需要的对象的类时，在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li>
<li>当一个类希望通过其子类来指定创建对象时，在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>

<h3 id="类实例代码-1">类实例代码</h3>

<p>代码如下：</p>

<pre><code>/// &lt;summary&gt;
/// 运算类
/// &lt;/summary&gt;
public class FmOperation
{
    private double _numberA = 0;
    private double _numberB = 0;

    public double NumberA
    {
        get { return _numberA; }
        set { _numberA = value; }
    }

    public double NumberB
    {
        get { return _numberB; }
        set { _numberB = value; }
    }

    /// &lt;summary&gt;
    /// 得到运算结果
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public virtual double GetResult()
    {
        double result = 0;
        return result;
    }
}

#region 各类运算符    
/// &lt;summary&gt;
/// 加法类
/// &lt;/summary&gt;
public class FmOperationAdd : FmOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA + NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 减法类
/// &lt;/summary&gt;
public class FmOperationSub : FmOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA - NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 乘法类
/// &lt;/summary&gt;
public class FmOperationMul : FmOperation
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA * NumberB;
        return result;
    }
}

/// &lt;summary&gt;
/// 除法类
/// &lt;/summary&gt;
public class FmOperationDiv : FmOperation
{
    public override double GetResult()
    {
        double result = 0;
        if (NumberB == 0)
            throw new Exception(&quot;除数不能为0。&quot;);
        result = NumberA / NumberB;
        return result;
    }
}
#endregion

#region 工厂方法    
/// &lt;summary&gt;
/// 工厂方法
/// &lt;/summary&gt;
interface IFactory
{
    FmOperation CreateOperation();
}

/// &lt;summary&gt;
/// 专门负责生产“+”的工厂
/// &lt;/summary&gt;
class FmAddFactory : IFactory
{
    public FmOperation CreateOperation()
    {
        return new FmOperationAdd();
    }
}

/// &lt;summary&gt;
/// 专门负责生产“-”的工厂
/// &lt;/summary&gt;
class FmSubFactory : IFactory
{
    public FmOperation CreateOperation()
    {
        return new FmOperationSub();
    }
}

/// &lt;summary&gt;
/// 专门负责生产“*”的工厂
/// &lt;/summary&gt;
class FmMulFactory : IFactory
{
    public FmOperation CreateOperation()
    {
        return new FmOperationMul();
    }
}

/// &lt;summary&gt;
/// 专门负责生产“/”的工厂
/// &lt;/summary&gt;
class FmDivFactory : IFactory
{
    public FmOperation CreateOperation()
    {
        return new FmOperationDiv();
    }
}
#endregion
</code></pre>

<h3 id="客户端代码-1">客户端代码</h3>

<p>代码如下：</p>

<pre><code>public void FactoryMethod()
{
    IFactory operFactory = new FmAddFactory();
    FmOperation oper = operFactory.CreateOperation();
    oper.NumberA = 1;
    oper.NumberB = 2;
    double result = oper.GetResult();
    Console.WriteLine(result);

    Console.Read();
}
</code></pre>

<h2 id="09-原型模式">09-原型模式</h2>

<p>原型模式就是用于创建重复的对象，当想要创建一个新的对象但是开销比较大或者想将对象的当前状态保存下来的时候，我们就可以使用原型模式。</p>

<h4 id="使用场景">使用场景</h4>

<p>大体上有三种使用场景：</p>

<ul>
<li>在需要一个类的大量对象的时候，使用原型模式是最佳选择，因为原型模式是在内存中对这个对象进行拷贝，要比直接new这个对象性能要好很多，在这种情况下，需要的对象越多，原型模式体现出的优点越明显。</li>
<li>如果一个对象的初始化需要很多其他对象的数据准备或其他资源的繁琐计算，那么可以使用原型模式。</li>
<li>当需要一个对象的大量公共信息，少量字段进行个性化设置的时候，也可以使用原型模式拷贝出现有对象的副本进行加工处理。</li>
</ul>

<h3 id="类实例代码-2">类实例代码</h3>

<p>代码如下：</p>

<pre><code>/// &lt;summary&gt;
/// 原型
/// &lt;/summary&gt;
public abstract class Base
{
    //因为String的特殊性，所以此次演示我们使用StringBuilder
    public StringBuilder Name { get; set; }
    public int Age { get; set; }

    public Base()
    {
        //模拟创建对象花费的开销
        Thread.Sleep(1000);
    }

    public Base(String name, int age)
    {
        this.Name = new StringBuilder(name);
        this.Age = age;
        //模拟创建对象花费的开销
        Thread.Sleep(1000);
    }

    //深拷贝
    public abstract Base Clone();
    //浅拷贝
    public abstract Base MClone();
}

//如果是要通过序列化来进行深拷贝的话，要打上Serializable标签
[Serializable]
public class Person : Base
{
    public Person()
        : base()
    {

    }
    public Person(String name, int age)
        : base(name, age)
    {

    }
    /// &lt;summary&gt;
    /// 深拷贝
    /// &lt;/summary&gt;
    /// &lt;returns&gt;返回一个全新的Person对象&lt;/returns&gt;
    public override Base Clone()
    {
        //创建一个内存流
        MemoryStream ms = new MemoryStream();
        //创建一个二进制序列化对象
        BinaryFormatter bf = new BinaryFormatter();
        //将当前对象序列化写入ms内存流中
        bf.Serialize(ms, this);
        //设置流读取的位置
        ms.Position = 0;
        //将流反序列化为Object对象
        return bf.Deserialize(ms) as Person;
    }

    /// &lt;summary&gt;
    /// 浅拷贝
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public override Base MClone() =&gt;
        //浅拷贝
        this.MemberwiseClone() as Person;
}
</code></pre>

<h3 id="客户端代码-2">客户端代码</h3>

<p>代码如下：</p>

<pre><code>#region 原方法
//用于计时
Stopwatch stopwatch = new Stopwatch();
stopwatch.Start();

Person p = new Person(&quot;a&quot;, 28);
Person p2 = new Person(&quot;a&quot;, 28);
Person p3 = new Person(&quot;a&quot;, 28);

stopwatch.Stop();
Console.WriteLine(&quot;耗时：&quot; + stopwatch.Elapsed);
Console.ReadKey();
#endregion

#region 浅层复制
//用于计时
Stopwatch stopwatch2 = new Stopwatch();
stopwatch.Start();

Person pmc = new Person(&quot;a&quot;, 10);
Person pmc1 = p.MClone() as Person;
Person pmc2 = p.MClone() as Person;

//记录下来name的值，后续通过即时窗口查看
StringBuilder name2 = pmc2.Name;
StringBuilder name1 = pmc1.Name;

stopwatch2.Stop();
Console.WriteLine(&quot;耗时：&quot; + stopwatch2.Elapsed);
Console.ReadKey();
#endregion

#region 深层复制
//用于计时
Stopwatch stopwatch3 = new Stopwatch();
stopwatch.Start();

Person pDeep = new Person(&quot;a&quot;, 10);
Person pDeep1 = p.Clone() as Person;
Person pDeep2 = p.Clone() as Person;

//记录下来name的值，后续通过即时窗口查看
StringBuilder nameDeep2 = pDeep2.Name;
StringBuilder nameDeep1 = pDeep1.Name;

stopwatch3.Stop();
Console.WriteLine(&quot;耗时：&quot; + stopwatch3.Elapsed);
Console.ReadKey();
#endregion
</code></pre>

<h2 id="13-建造者模式">13-建造者模式</h2>

<p>概述：将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p>

<p>建造者模式中的角色：</p>

<ul>
<li>建造者（Builder）：为创建一个产品对象的各个部件指定抽象接口。</li>
<li>具体建造者（ConcreteBuilder）：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并 提供一个检索产品的接口。</li>
<li>指挥者（Director）：指挥并构造一个使用Builder接口的对象。该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li>
<li>产品（Product）：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>

<h3 id="uml图-1">UML图</h3>

<p><img src="https://SLTaurus.github.io/images/Pattern/Builder.png" alt="Builder" /></p>

<h3 id="优点-缺点和应用场景-1">优点、缺点和应用场景</h3>

<p>优点：</p>

<ul>
<li>用户只需要指定要建造的类型就可以得到它们，而具体的建造过程和细节不需要知道。</li>
<li>建造代码与表示相分离，如果要改变一个产品的内部表示，只要再定义一个新的具体的建造者就可以了。</li>
<li>建造过程由指挥者来控制，建造细节由一个抽象类来控制，对于实现建造细节的具体类来说，不会遗漏某一个步骤。</li>
</ul>

<p>缺点：</p>

<ul>
<li>以上例子说明，现在我要增加产品的一个细节，如把创建脚的过程也添加进来，看我们需要改哪些类。Buider,FatPersonBuilder,ThinPersonBuilder（甚至更多，如果你实现了TallPersonBuilder,ShortPersonBuilder等),PersonDirector，我们对修改也就开放了。</li>
</ul>

<p>实用范围：</p>

<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当复杂对象的部件相对稳定，不会发生变化时</li>
</ul>

<h3 id="类实例代码-3">类实例代码</h3>

<p>代码如下：</p>

<pre><code>public abstract class Builder
{
    protected People people = new People();
    public abstract void SetCountry();
    public abstract void SetSpeak();
    public abstract void SetSkinColor();

    public People getResult()
    {
        return people;
    }
}

/// &lt;summary&gt;
/// 被创建的对象，对象会出现局部的不同，
/// &lt;/summary&gt;
public class People
{
    public People()
    {
        Console.Write(&quot;我们都是人，但是&quot;);
    }
}

public class USA : Builder
{
    private string _country;
    private string _speak;
    private string _skincolor;
    public USA(string skincolor, string country, string speak)
    {
        this._country = country;
        this._skincolor = skincolor;
        this._speak = speak;
    }
    public override void SetSkinColor()
    {
        Console.Write(_skincolor + &quot;的&quot;);
    }
    public override void SetCountry()
    {
        Console.Write(_country);
    }

    public override void SetSpeak()
    {
        Console.Write(&quot;讲&quot; + _speak);
    }
}

public class UK : Builder
{
    private string _country;
    private string _speak;
    private string _skincolor;
    public UK(string skincolor, string country, string speak)
    {
        this._country = country;
        this._skincolor = skincolor;
        this._speak = speak;
    }
    public override void SetSkinColor()
    {
        Console.Write(_skincolor + &quot;的&quot;);
    }
    public override void SetCountry()
    {
        Console.Write(_country);
    }

    public override void SetSpeak()
    {
        Console.Write(&quot;讲&quot; + _speak);
    }
}

/// &lt;summary&gt;
/// 执行者,创建对象
/// &lt;/summary&gt;
public class Director
{
    private Builder builder;
    public Director(Builder bu)
    {
        this.builder = bu;
    }
    public People Construct()
    {
        builder.SetSkinColor();
        builder.SetCountry();
        builder.SetSpeak();
        return builder.getResult();
    }
}
</code></pre>

<h3 id="客户端代码-3">客户端代码</h3>

<p>代码如下：</p>

<pre><code>public void BuilderDemo()
{
    Builder builder = new USA(&quot;黑皮肤&quot;, &quot;美国人&quot;, &quot;英语&quot;);
    Director director = new Director(builder);
    People product = director.Construct();
    Console.Write(&quot;\r\n&quot;);

    Builder builder1 = new USA(&quot;白皮肤&quot;, &quot;英国人&quot;, &quot;日语&quot;);
    Director director1 = new Director(builder1);
    People product1 = director1.Construct();
    Console.ReadKey();
}
</code></pre>

<h2 id="15-抽象工厂模式">15-抽象工厂模式</h2>

<blockquote>
<p>更详细的请参考：<a href="https://www.cnblogs.com/pangjianxin/p/7993313.html">C#设计模式之6：抽象工厂模式</a></p>
</blockquote>

<p>分别学习了简单工厂模式和工厂方法模式，他们各自存在着缺点：简单工厂中如果需要添加新的生产产品，就需要增加额外的逻辑代码，整体逻辑复杂度会变大，难以维护。而工厂的方法的出现解决了简单工厂的缺点，产品的增加则是增加具体的工厂类即可，但是，我们的现实生活中，大多数工厂是不可能只创建单个一种产品的，它们都是多元化的，创建着一系列的产品，例如一个电脑代工生厂生产电脑（电脑就是一个产品族，其中有笔记本和桌面电脑），如果他给宏碁代工，则产出宏碁电脑、代工华硕，则生产华硕电脑、代工联想，则生产联想电脑等。抽象工厂也是为了改缺点而生的，本质上工厂方法是抽象工厂的一种极端情况（即只生产一种产品）。抽象工厂针对的是产品族。</p>

<ul>
<li>例子：我们以电脑代工厂生产电脑作为例子，讲述抽象工厂。一个代工厂分别代工生产联想与宏碁电脑（而电脑中又分为笔记本电脑及台式电脑）。</li>
<li>抽象工厂模式的优点：针对产品族而生。</li>
<li>抽象工厂模式的缺点：针对产品族而生 ，对于扩展系列产品支持（比如说添加电脑品牌），但是对于添加新产品则不支持（比如说添加平板电脑）。</li>
<li>应用场景：所以他的应用场景也只有产品族情况下使用。</li>
</ul>

<h3 id="uml图-2">UML图</h3>

<p><img src="https://SLTaurus.github.io/images/Pattern/AbstractUML.png" alt="AbstractUML" /></p>

<h3 id="类实例代码-4">类实例代码</h3>

<p>代码如下：</p>

<pre><code>#region 电脑品类抽象类
/// &lt;summary&gt;
/// 产品分别为笔记本电脑和台式机
/// &lt;/summary&gt;
public abstract class NotebookComputer
{
    public abstract void WriteProduct();//生产计算机输出
}
public abstract class DesktopComputer
{
    public abstract void WriteProduct();
}
#endregion

#region 对应品牌电脑的类

/// &lt;summary&gt;
/// 联想的电脑
/// &lt;/summary&gt;
public class LenovoNotebookComputer : NotebookComputer
{
    public override void WriteProduct()
    {
        Console.WriteLine(&quot;联想笔记本电脑&quot;);
    }
}
public class LenovoDesktopComputer : DesktopComputer
{
    public override void WriteProduct()
    {
        Console.WriteLine(&quot;联想台式电脑&quot;);
    }
}

/// &lt;summary&gt;
/// 宏碁的电脑
/// &lt;/summary&gt;
public class AcerNotebookComputer : NotebookComputer
{
    public override void WriteProduct()
    {
        Console.WriteLine(&quot;宏碁笔记本电脑&quot;);
    }
}


public class AcerDesktopComputer : DesktopComputer
{

    public override void WriteProduct()
    {
        Console.WriteLine(&quot;宏碁台式电脑&quot;);
    }
}
#endregion

/// &lt;summary&gt;
/// 抽象工厂类，提供两种不同的电脑品牌的生产
/// &lt;/summary&gt;
public abstract class ComputerAbstractFactory
{
    public abstract NotebookComputer CreateNotebookComputer();//抽象工厂提供一系列产品的接口，我们例子这里的代工工厂分为笔记本和台式电脑两种
    public abstract DesktopComputer CreateDesktopComputer();
}

#region 工厂中的对应品牌的产线
/// &lt;summary&gt;
/// 这个代工厂里的联想产线负责生产联想的笔记本和台式机
/// &lt;/summary&gt;
public class LenovoComputer : ComputerAbstractFactory
{

    public override DesktopComputer CreateDesktopComputer()
    {
        return new LenovoDesktopComputer();
    }

    public override NotebookComputer CreateNotebookComputer()
    {
        return new LenovoNotebookComputer();
    }
}

/// &lt;summary&gt;
/// 宏碁产线负责生产宏碁的笔记本和台式机
/// &lt;/summary&gt;
public class AcerComputer : ComputerAbstractFactory
{
    public override DesktopComputer CreateDesktopComputer()
    {
        return new AcerDesktopComputer();
    }

    public override NotebookComputer CreateNotebookComputer()
    {
        return new AcerNotebookComputer();
    }
}
#endregion
</code></pre>

<h3 id="客户端代码-4">客户端代码</h3>

<p>代码如下：</p>

<pre><code>//生产联想的电脑
ComputerAbstractFactory lenovoComputer = new LenovoComputer();//创建联想生产线
NotebookComputer lenovoNotebookComputer = new LenovoNotebookComputer();//创建联想笔记本电脑
DesktopComputer lenovoDesktopComputer = new LenovoDesktopComputer();//创建联想桌面电脑
lenovoNotebookComputer.WriteProduct();
lenovoDesktopComputer.WriteProduct();
Console.WriteLine(&quot;*************************************&quot;);
//生产宏碁的电脑
ComputerAbstractFactory acerComputer = new AcerComputer();
NotebookComputer acerNotebookComputer = new AcerNotebookComputer();
DesktopComputer acerDesktopComputer = new AcerDesktopComputer();
acerNotebookComputer.WriteProduct();
acerDesktopComputer.WriteProduct();
</code></pre>

<h2 id="21-单例模式">21-单例模式</h2>

<p>所有类都有构造函数，不编码则系统默认生成空的构造函数，若有显示定义的构造函数，默认的构造函数就会失效，将类的构造函数写成private的，外部程序就不能用new来实例化它了，这样一来，客户端不在考虑是否需要去实例化的问题，而把责任都给了应该负责的类去处理，其实这就是单例模式。</p>

<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点，</p>

<p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象，一个最好的办法就是，让类自身负责保存它的唯一实例，这个类可以保证没有其它实例可以被创建，并且它可以提供一个访问该实例的方法。</p>

<p>单例模式除了可以保证唯一的实例外，它还可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问。</p>

<h3 id="单例实例代码">单例实例代码</h3>

<p>代码如下：</p>

<pre><code>public class Singleton
{
    private static Singleton instance;

    private static readonly object syncRoot = new object();

    private Singleton()                                    //构造函数让其private，堵死外界利用new创建实例的可能，
    {

    }

    public static Singleton GetInstance()                  //此方法是获得本类实例的唯一全局访问点，
    {
        if (instance == null)                              //若实例不存在，则new一个新实例，否则返回已有实例，
        {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>

<h3 id="多线程时的单例">多线程时的单例</h3>

<p>多线程的程序中，多个线程同时访问Singleton类，调用GetInstance方法，会有可能造成创建多个实例，</p>

<p>可以给进程一把锁来处理，lock是确保当一个线程位于代码的临界区时，另一个线程不能进入临界区，如果其它线程试图进入锁定的代码，则它将一直等待即被阻止，直到该对象被释放。</p>

<pre><code>public class Singleton
{
    private static Singleton instance;

    private static readonly object syncRoot = new object();//加锁时，instance实例有没有被创建过都还不知道，无法对其加锁，

    private Singleton()                                    //构造函数让其private，堵死外界利用new创建实例的可能，
    {

    }

    public static Singleton GetInstance()                  //此方法是获得本类实例的唯一全局访问点，
    {
        lock (syncRoot)                                    //在同一时刻加了锁的那部分程序只有一个线程可以进入，
        {
            if (instance == null)                          //若实例不存在，则new一个新实例，否则返回已有实例，
            {
                instance = new Singleton();
            }
        }
        return instance;
    }
}
</code></pre>

<h4 id="双重锁定">双重锁定</h4>

<p>当instance为nul并且同时有两个线程调用GetInstance方法时，它们都可以通过第一重instance==null的判断，然后由于lock机制，两个线程则只有一个进入，另一个在外排队等候，必须要其中的一个进入并出来后，另一个才能进入，而此时如果没有了第二重的instance是否判断为null的判断，则第一个线程创建了实例，而第二个线程还是可以继续再创建新的实例，这就没有达到单例的目的。</p>

<pre><code>public class Singleton
{
    private static Singleton instance;

    private static readonly object syncRoot = new object();//加锁时，instance实例有没有被创建过都还不知道，无法对其加锁，

    private Singleton()                                    //构造函数让其private，堵死外界利用new创建实例的可能，
    {

    }

    public static Singleton GetInstance()                  //此方法是获得本类实例的唯一全局访问点，
    {
        if (instance == null)                              //先判断实例是否存在，不存在再加锁处理，
        {
            lock (syncRoot)                                //在同一时刻加了锁的那部分程序只有一个线程可以进入，
            {
                if (instance == null)                      //若实例不存在，则new一个新实例，否则返回已有实例，
                {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>

<h4 id="静态初始化">静态初始化</h4>

<p>C#与公共语言运行库也提供了一种“静态初始化”方法，这种方法不需要开发人员显示的编写线程安全代码，即可解决多线程环境下它是不安全的问题。</p>

<pre><code>public sealed class Singleton                                      //阻止发生派生，而派生可能会增加实例，
{
    private static readonly Singleton instance = new Singleton();  //在第一次引用类的任何成员时创建实例，公共语言运行库负责处理变量初始化，

    private Singleton() { }

    public static Singleton GetInstance()
    {
        return instance;
    }
}
</code></pre>

<p>这样的实现与前面的示例类似，也是解决了单例模式试图解决的两个基本问题，全局访问和实例化控制，公共静态属性为访问实例提供了一个全局的访问点，不同之处在于它依赖公共语言运行库来初始化变量。</p>

<p>由于构造函数时私有的，因此不能在类本身以外实例化Singleton类，因此，变量引用的是可以在系统中唯一存在的实例，注意instance变量标记为readonly。意味着只能在静态初始化期间或在类构造函数中分配变量，由于静态初始化的方式是在自己被加载时就将自己实例化，所以被形象称为饿汉单例模式，原先的单例模式处理方式是要在第一次被引用时，才会将自己实例化，所以称之为懒汉单例模式。</p>

<p>其区别为，饿汉式即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源，而懒汉式又会面临着多线程访问的安全性问题，需要双重锁定这样的处理才可以保证安全。</p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://SLTaurus.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>

                  </div>
                
              
            
			
			  
  <span id="/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/" class="leancloud_visitors" data-flag-title="24种设计模式之创建型">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">100</span>
    <p></p>
  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'qmkacTy81gjW31F1mPV0T8UP-gzGzoHsz',
        appKey: '27rweMzy4Q07Rqa7s4RKVD8O',
        notify:  false , 
        verify:  false , 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://SLTaurus.github.io/2019/12/mysql%E6%8B%BE%E9%81%97/" data-tooltip="MySql拾遗">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/" data-tooltip="24种设计模式之结构型">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2020 <a href="https://github.com/SLTaurus">轲</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://SLTaurus.github.io/2019/12/mysql%E6%8B%BE%E9%81%97/" data-tooltip="MySql拾遗">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/" data-tooltip="24种设计模式之结构型">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://SLTaurus.github.io/2020/01/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2FSLTaurus.github.io%2F2020%2F01%2F24%25E7%25A7%258D%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E4%25B9%258B%25E5%2588%259B%25E5%25BB%25BA%25E5%259E%258B%2F">
          <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2FSLTaurus.github.io%2F2020%2F01%2F24%25E7%25A7%258D%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E4%25B9%258B%25E5%2588%259B%25E5%25BB%25BA%25E5%259E%258B%2F">
          <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2FSLTaurus.github.io%2F2020%2F01%2F24%25E7%25A7%258D%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E4%25B9%258B%25E5%2588%259B%25E5%25BB%25BA%25E5%259E%258B%2F">
          <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://SLTaurus.github.io/images/touxiang.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">轲</h4>
    
      <div id="about-card-bio">作为一个好的程序员，一定要有执着钻研、刻苦学习、认真仔细和精益求精的朴素品质。</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        程序猿
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        广州
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://SLTaurus.github.io/images/cover.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://SLTaurus.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


  
    <script src="https://SLTaurus.github.io/js/myscript.js"></script>
  

<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/SLTaurus.github.io\/2020\/01\/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B\/';
          
            this.page.identifier = '\/2020\/01\/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

