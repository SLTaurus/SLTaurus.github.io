<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.57.2 with theme Tranquilpeak 0.4.7-BETA">
<meta name="author" content="轲">
<meta name="keywords" content="JavaScript, C#, .NET, 个人博客">
<meta name="description" content="这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。">


<meta property="og:description" content="这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript入门经典第6版笔记(下)">
<meta name="twitter:title" content="JavaScript入门经典第6版笔记(下)">
<meta property="og:url" content="https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
<meta property="twitter:url" content="https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
<meta property="og:site_name" content="SLTaurus的安全屋">
<meta property="og:description" content="这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。">
<meta name="twitter:description" content="这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2019-09-23T14:46:39">
  
  
    <meta property="article:modified_time" content="2019-09-23T14:46:39">
  
  
  
    
      <meta property="article:section" content="JavaScript">
    
  
  
    
      <meta property="article:tag" content="JavaScript">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://SLTaurus.github.io/images/JavaScript/JavaScript.jpg">
  <meta property="twitter:image" content="https://SLTaurus.github.io/images/JavaScript/JavaScript.jpg">


  <meta property="og:image" content="https://SLTaurus.github.io/images/cover.jpg">
  <meta property="twitter:image" content="https://SLTaurus.github.io/images/cover.jpg">




  <meta property="og:image" content="https://SLTaurus.github.io/images/touxiang.jpg">
  <meta property="twitter:image" content="https://SLTaurus.github.io/images/touxiang.jpg">


    <title>JavaScript入门经典第6版笔记(下)</title>

    <link rel="icon" href="https://SLTaurus.github.io/favicon.jpg">
    

    

    <link rel="canonical" href="https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://SLTaurus.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://SLTaurus.github.io/">SLTaurus的安全屋</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://SLTaurus.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://SLTaurus.github.io/images/touxiang.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://SLTaurus.github.io/#about">
          <img class="sidebar-profile-picture" src="https://SLTaurus.github.io/images/touxiang.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">轲</h4>
        
          <h5 class="sidebar-profile-bio">只要坚持希望不气馁，生活迟早会让我们变得无所不能。</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">类别</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/SLTaurus" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://SLTaurus.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-center
              post-header-cover--full"
       style="background-image:url('/images/cover.jpg')"
       data-behavior="5">
    
  </div>


      <div id="main" data-behavior="5"
        class="hasCover
               hasCoverMetaOut
               hasCoverCaption">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
            <span class="post-header-cover-caption caption">JavaScript笔记</span>
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title" itemprop="headline">
      JavaScript入门经典第6版笔记(下)
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-09-23T14:46:39&#43;08:00">
        
  九月 23, 2019

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://SLTaurus.github.io/categories/javascript">JavaScript</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。</p>

<h1 id="table-of-contents">目录</h1><nav id="TableOfContents">
<ul>
<li><a href="#使用javascript库">使用JavaScript库</a>
<ul>
<li><a href="#库">库</a>
<ul>
<li><a href="#为什么要使用库">为什么要使用库</a>
<ul>
<li><a href="#库能做什么">库能做什么</a></li>
</ul></li>
<li><a href="#常见的库">常见的库</a>
<ul>
<li><a href="#property框架">property框架</a></li>
<li><a href="#dojo">Dojo</a></li>
<li><a href="#yahoo-ui">Yahoo！UI</a></li>
<li><a href="#mootools">MooTools</a></li>
<li><a href="#jquery">jQuery</a></li>
</ul></li>
<li><a href="#prototype-js介绍">prototype.js介绍</a>
<ul>
<li><a href="#函数">$()函数</a></li>
<li><a href="#f-函数">#F()函数</a></li>
<li><a href="#form对象">Form对象</a></li>
<li><a href="#示例">示例</a></li>
</ul></li>
<li><a href="#小结">小结</a></li>
</ul></li>
<li><a href="#jquery入门">jQuery入门</a>
<ul>
<li><a href="#在页面里使用jquery">在页面里使用jQuery</a></li>
<li><a href="#jquer的-document-ready处理器">jQuer的$(document).ready处理器</a></li>
<li><a href="#选择页面元素">选择页面元素</a></li>
<li><a href="#操作html内容">操作HTML内容</a></li>
<li><a href="#显示和隐藏元素">显示和隐藏元素</a></li>
<li><a href="#元素动画">元素动画</a>
<ul>
<li><a href="#淡入淡出">淡入淡出</a></li>
<li><a href="#滑动">滑动</a></li>
<li><a href="#动画">动画</a></li>
</ul></li>
<li><a href="#命令链">命令链</a></li>
<li><a href="#处理事件">处理事件</a></li>
<li><a href="#小结-1">小结</a></li>
</ul></li>
<li><a href="#jquery-ui">jQuery UI</a>
<ul>
<li><a href="#jquery-ui-是什么">jQuery UI 是什么</a></li>
<li><a href="#如何在页面里引用jquery-ui">如何在页面里引用jQuery UI</a>
<ul>
<li><a href="#使用-themeroller">使用 ThemeRoller</a></li>
</ul></li>
<li><a href="#交互">交互</a>
<ul>
<li><a href="#拖和放">拖和放</a></li>
<li><a href="#调整大小">调整大小</a></li>
<li><a href="#排序">排序</a></li>
</ul></li>
<li><a href="#使用微件">使用微件</a>
<ul>
<li><a href="#可折叠控件">可折叠控件</a></li>
<li><a href="#日期拾取器">日期拾取器</a></li>
<li><a href="#选项卡">选项卡</a></li>
</ul></li>
<li><a href="#小结-2">小结</a></li>
</ul></li>
<li><a href="#ajax-和-jquery">Ajax 和 jQuery</a>
<ul>
<li><a href="#ajax解析">Ajax解析</a>
<ul>
<li><a href="#ajax-入门">Ajax 入门</a></li>
<li><a href="#xmlhttprequest对象">XMLHttpRequest对象</a></li>
<li><a href="#不同浏览器的不同规则">不同浏览器的不同规则</a></li>
<li><a href="#方法和属性">方法和属性</a></li>
<li><a href="#与服务器通信">与服务器通信</a></li>
<li><a href="#在服务器端发生了什么">在服务器端发生了什么</a></li>
<li><a href="#处理服务器响应">处理服务器响应</a></li>
</ul></li>
<li><a href="#使用jquery实现ajax">使用jQuery实现Ajax</a></li>
<li><a href="#篇外之一get对比post">篇外之一GET对比POST</a></li>
<li><a href="#篇外之二w3school上面的jquery-ajax-get-和-post-方法诠释">篇外之二W3school上面的jQuery - AJAX get() 和 post() 方法诠释</a></li>
</ul></li>
</ul></li>
<li><a href="#高级注题">高级注题</a>
<ul>
<li><a href="#读取和写入cookie">读取和写入cookie</a>
<ul>
<li><a href="#什么是-cookie">什么是 cookie</a>
<ul>
<li><a href="#cookie的局限">cookie的局限</a></li>
</ul></li>
<li><a href="#document-cookie-属性">document.cookie 属性</a>
<ul>
<li><a href="#数据的编码和解码">数据的编码和解码</a></li>
</ul></li>
<li><a href="#cookie-组成">cookie 组成</a></li>
<li><a href="#编写-cookie">编写 cookie</a></li>
<li><a href="#编写cookie的函数">编写cookie的函数</a></li>
<li><a href="#读取cookie">读取cookie</a></li>
<li><a href="#删除-cookie">删除 cookie</a></li>
<li><a href="#在一个cookie里设置多个值">在一个cookie里设置多个值</a></li>
</ul></li>
<li><a href="#javascript新功能">JavaScript新功能</a>
<ul>
<li><a href="#类">类</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
<li><a href="#模块">模块</a></li>
<li><a href="#使用let和const">使用let和const</a></li>
<li><a href="#模板字符串">模板字符串</a></li>
<li><a href="#使用for-of访问数组">使用for-of访问数组</a></li>
<li><a href="#小结-3">小结</a></li>
</ul></li>
<li><a href="#使用框架">使用框架</a>
<ul>
<li><a href="#软件框架">软件框架</a>
<ul>
<li><a href="#为何要使用框架">为何要使用框架</a></li>
<li><a href="#框架和库不同">框架和库不同</a></li>
</ul></li>
<li><a href="#模型-视图-控制器-mvc-架构">模型-视图-控制器（MVC）架构</a>
<ul>
<li><a href="#模型">模型</a></li>
<li><a href="#视图">视图</a></li>
<li><a href="#控制器">控制器</a></li>
</ul></li>
<li><a href="#针对webapp使用mvc框架">针对WebAPP使用MVC框架</a></li>
<li><a href="#angularjs-框架">AngularJS 框架</a>
<ul>
<li><a href="#angularjs-概览">AngularJS 概览</a></li>
<li><a href="#在页面中包含angularjs">在页面中包含AngularJS</a></li>
<li><a href="#用ng-指令扩展html">用ng-指令扩展HTML</a></li>
<li><a href="#作用域">作用域</a></li>
<li><a href="#指令">指令</a></li>
<li><a href="#表达式">表达式</a></li>
<li><a href="#过滤器">过滤器</a></li>
</ul></li>
<li><a href="#构建一个angularjs应用程序">构建一个AngularJS应用程序</a></li>
<li><a href="#小结-4">小结</a></li>
</ul></li>
<li><a href="#web页面之外的javascript">Web页面之外的JavaScript</a></li>
</ul></li>
</ul>
</nav>

<h1 id="使用javascript库">使用JavaScript库</h1>

<h2 id="库">库</h2>

<p>库就是可重用的JavaScript代码的集合，让我们只需要在代码中添加几行代码就可以实现复杂的操作。</p>

<h3 id="为什么要使用库">为什么要使用库</h3>

<p>一些JavaScript开发人员强烈建议编写自己的代码而不是使用库，原因如下：</p>

<ul>
<li>使用库时只是调用其他人编写的算法和函数，所以我们不能确切了解库里的代码是如何运作的。</li>
<li>JavaScript库中有很多我们不会用到的代码，但是用户仍然需要下载它。</li>
</ul>

<p>使用库的好处：</p>

<ul>
<li>不需要编写别人已经写过的代码，常用的库包含了程序猿经常要用到的函数。这些库得到了很多人的使用和评价，经过了更完整的测试和调试，比我们的代码会更完善点。</li>
<li>吸取其他程序猿的思路，我们可以用这些优秀的乐于分享的程序猿的代码成果来完善改进自己的代码。</li>
<li>利用编写细致的库可以避免跨浏览器时JavaScript可能产生的问题。编写库的程序猿和他的用户会测试各种常见的浏览器。</li>
<li>大部分的库的文件不是很大，下载不会造成明显的影响。对于需要缩短下载时间的场合，大多数库都提供了压缩的版本，我们还可以查看库的代码，只保留需要使用的部分。</li>
</ul>

<h4 id="库能做什么">库能做什么</h4>

<p>库的功能是多种多样的，取决于它应用的领域、创建者的目的和需求。但一些功能是大多库都包括的：</p>

<ul>
<li>封装DOM方法。JavaScript库可以提供方便的方式来选择和管理页面的元素或元素组，prototype.js就是如此。</li>
<li>动画。我们只需要很少的代码就可以实现滑动、淡出、晃动、变形、折叠、跳动等页面效果，而且在很多浏览器上面都是可以正常运行的。</li>
<li>拖放。真正跨浏览器拖放是很复杂的，使用库可以大大简化这个工作。</li>
<li>Ajax。不必考虑XMLHttpRequest实例化问题，不必关心回调函数和状态代码，就能动态更新页面内容。</li>
</ul>

<h3 id="常见的库">常见的库</h3>

<h4 id="property框架">property框架</h4>

<p>property框架(<a href="http://www.propertyjs.org">http://www.propertyjs.org</a>)的优势在于DOM扩展和Ajax处理，在JSON支持与创建和继承类方面也做得不错。property框架作为单独的库进行发布，但也会作为更大项目的组件，比如Ruby on Rails和Script.aculo.us库。</p>

<h4 id="dojo">Dojo</h4>

<p>Dojo(<a href="http://www.dojotoolkit.org">http://www.dojotoolkit.org</a>)是一个开源工具集，能够简化创建程序和用户界面的工作，功能包括扩展的字符串和数学函数，还由动画和Ajax。最新版不仅支持全部的支流浏览器，还支持手机环境（Dojo Mobile），包括苹果的IOS、Android和Blackberry等平台。</p>

<h4 id="yahoo-ui">Yahoo！UI</h4>

<p>Yahoo！UI库（<a href="http://developer.yaoo.com/yui/">http://developer.yaoo.com/yui/</a>）是由Yahoo！开发的开源程序，功能包括动画、DOM、事件管理及一些方便的用户界面元素，比如日历和滑块。</p>

<h4 id="mootools">MooTools</h4>

<p>MooTools（<a href="http://mootool.net/">http://mootool.net/</a>）是一个小型模块化JavaScript框架，提供易于理解的、文档清晰的API（应用程序接口），能够帮我们创建功能强大的、灵活的跨浏览器程序。</p>

<h4 id="jquery">jQuery</h4>

<p>jQuery（<a href="http://jquery.com">http://jquery.com</a>）是一个小型高效的JavaScript库，简化了多种开发工作，比如HTML文档转换、事件处理、动画和Ajax调用，适合快速开发交互站点。</p>

<h3 id="prototype-js介绍">prototype.js介绍</h3>

<p>这里是展示prototype.js库对DOM操作、HTML表单和XMLHttpRequest对象的强大支持，可以如何简化Javascript代码。备注：作为对后世很多库产生过重大影响的库，Prototype 对前端技术进步做出的贡献不可磨灭，但是鉴于其主要功能都能被更好用的 jQuery（或者其它同类型的库）甚至是标准取代了，Prototype 早就已经事实上退出历史舞台了。</p>

<h4 id="函数">$()函数</h4>

<p>$()基本就是getElementById()方法的快捷方式，getElementById(&ldquo;div1&rdquo;)被简化为$(&ldquo;div1&rdquo;)。$()可以接收多个元素的Id作为参数返回元素所组成的数组。</p>

<pre><code>mydataArray = $(&quot;div1&quot;,&quot;div2&quot;,&quot;div3&quot;);
</code></pre>

<p>mydataArray[0]包含元素ID为div1的值，依次类推。</p>

<h4 id="f-函数">#F()函数</h4>

<p>#F()函数以表单的输入元素或它的ID作为参数，返回它包含的值。比如下面的HTML脚本：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script src=&quot;Resources/prototype.js&quot;&gt;&lt;/script&gt;    
    &lt;script&gt;
    function ShowInput(id) {
        var mydata = $F(id);
        alert(mydata);
    }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;text&quot; id=&quot;input1&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;查询&quot; onclick=&quot;ShowInput('input1')&quot; /&gt;   &lt;br /&gt;&lt;br /&gt;
    &lt;select id=&quot;input2&quot; name=&quot;input2&quot;&gt;
        &lt;option value=&quot;0&quot;&gt;选项A&lt;/option&gt;
        &lt;option value=&quot;1&quot;&gt;选项B&lt;/option&gt;
        &lt;option value=&quot;2&quot;&gt;选项C&lt;/option&gt;
    &lt;/select&gt;
    &lt;input type=&quot;button&quot; value=&quot;查询&quot; onclick =&quot;ShowInput('input2')&quot; /&gt;   
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>$F(&lsquo;input1&rsquo;)返回的是文本框的值，$F(&lsquo;input2&rsquo;)返回的是选择框当前选中的值。我们可以用同样的方式对文本框和选择框使用#F()函数，不必考虑输入元素的类型，从而非常方便的返回相应的值。</p>

<h4 id="form对象">Form对象</h4>

<p>prototype.js定义了一个Form对象，它包含的一些方法能够简化HTML表单操作。比如调用getElementById()方法可以返回一个数组，其中包含表单的输入字段：</p>

<pre><code>inputs = From.getElementById(&quot;thisform&quot;);
</code></pre>

<p>serialize（）方法可以把输入名称和值转换为URL兼容的序列：</p>

<pre><code>inputslist = From.serialize(&quot;thisform&quot;);
</code></pre>

<p>在前面的这行代码里，变量inputslist会包含序列化的&rdquo;参数/值&rdquo;对：</p>

<pre><code>file11=value1&amp;file12=value2&amp;file13=value3...
</code></pre>

<p>Form.disable(&ldquo;thisform&rdquo;)和Form.enable(&ldquo;thisform&rdquo;)从名称就可以看出它们的功能。</p>

<h4 id="示例">示例</h4>

<p>用getElementById()方法收集HTML表单的一些相关信息。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script src=&quot;Resources/prototype.js&quot;&gt;&lt;/script&gt;    
    &lt;script&gt;
    function ShowFormFileds() {
        var form = $('exampleForm');
        var message = '';
        var fileds = form.getElements();
        for (var i = 0; i &lt; fileds.length; i++) {
            message += &quot;Filed Name：&quot; + fileds[i].name + &quot; Value：&quot; + fileds[i].value + &quot;\n&quot;;            
        }
        alert(message);
    }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;exampleForm&quot; action=&quot;#&quot; onsubmit=&quot;return false&quot;&gt;
        UserName：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt;
        Telephone：&lt;input type=&quot;text&quot; name=&quot;telephone&quot; /&gt;&lt;br /&gt;
        Message：&lt;input type=&quot;text&quot; name=&quot;message&quot; /&gt;&lt;br /&gt;
    &lt;/form&gt;
    &lt;input type=&quot;button&quot; value=&quot;结果&quot; onclick=&quot;ShowFormFileds()&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="小结">小结</h3>

<p>在很多情况下，利用库都可以简化JavaScript的编写过程。这些库把众多常用的对象和方法包装为便于使用的形式，让程序猿在添加或删除事件监听器或是访问表单元素是不必再担心跨浏览器的问题，这里只是简单介绍了几个最常用的JavaScript库。</p>

<h2 id="jquery入门">jQuery入门</h2>

<p>虽然存在着很多JavaScript库，但jQuery显然是最常用的，而且几乎是最容易拓展的一个。大量开发人员给jQuery提供了开源的插件，让我们几乎可以为任何应用找到适当的插件。这些范围广泛的插件和易于使用的简单语法让jQuery成为一个伟大的库。</p>

<h3 id="在页面里使用jquery">在页面里使用jQuery</h3>

<p>在页面里引用jQuery主要有两种方式：</p>

<ul>
<li>一种是将jQuery下载下来然后在页面的<code>&lt;head&gt;</code>部分用<code>&lt;script&gt;</code>标签来包含jQuery库，示例：<code>&lt;script src=&quot;Resources/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;</code>。</li>
<li>第二种是使用远程方式，用“内容分发网络”，也就是CDN的方式引用它。除了不用下载jQuery之外，这种方式还有一些优点：当浏览器需要使用JQuery时，它很有可能已经存在缓存里了，另外CDN通常能够保证从最近的地理位置的服务器提供文件，从而减少加载时间。jQuery站的CDN可以在网络上找到很多，这里的范例如下：<code>&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code>。</li>
</ul>

<p>除非有特定的理由需要在自己的服务器上加载jQuery，一般情况下CDN方式是更好的选择。</p>

<h3 id="jquer的-document-ready处理器">jQuer的$(document).ready处理器</h3>

<p>本书多次使用了window.onload处理器，而jQuery具有自己的相应方法：</p>

<pre><code>$(document).ready(function () {
//jQuery代码
        });
</code></pre>

<p>与window.onload一样，它完成两件事情：</p>

<ul>
<li>确保在DOM可用之后，也就是代码中可能访问的元素都已经存在了，再执行代码，从而避免产生错误。</li>
<li>把语义层（HTML）和表现层（CSS）分离开，让代码更清晰。</li>
</ul>

<p>jQuery相比window.onload还有一个优点：不是一定等到页面加载完成才运行代码。在使用JQuery的$(document).ready时候，只要DOM树构造完成，代码就开始运行，而不会等到图像和其他资源都加载完，这对性能改善略有帮助。</p>

<h3 id="选择页面元素">选择页面元素</h3>

<p>在jQuery里，利用操作符$(&ldquo;&rdquo;)就可以选择HTML元素。下面是一些使用范例：</p>

<pre><code>$(&quot;span&quot;);                  //全部span元素
$(&quot;#elem&quot;);                 //id 为&quot;elem&quot;的HTML元素
$(&quot;.classname&quot;);            //类为&quot;classname&quot;的HTML元素
$(&quot;div#elem&quot;);              //id为&quot;elem&quot;的＜div＞元素
$(&quot;ul li a.menu&quot;);          //类为&quot;menu&quot;且嵌套在列表项里的锚点
$(&quot;p ＞ span&quot;);              //p的直接子元素 span
$(&quot;input[type=password]&quot;);  //具有指定类型的输入元素
$(&quot;p:first&quot;);               //页面上第一个段落
$(&quot;p:even&quot;);                //全部偶数段落
</code></pre>

<p>关于DOM和CSS的选择符就是上述这些，但jQuery还有一些自己定制的选择符，比如：</p>

<pre><code>$(&quot;:header&quot;);       //标题元素(hl 到 h6)
$(&quot;：button&quot;);       //全部按钮元素(输入框或按钮)
$(&quot;：radio&quot;);        //单选钮
$(&quot;:check box&quot;);    //选择框
$(&quot;:checked&quot;);      //选中状态的选择框或单选钮
</code></pre>

<p>前面这几条jQuery语句都会返回一个对象，其中包括由指定DOM元素组成的数组。这些 语句并没有实际操作，而只是从DOM获取相应的元素。</p>

<h3 id="操作html内容">操作HTML内容</h3>

<p>操作页面元素内容是最能体现jQuery高效工作的方面之一。html()和text()方法能够获取和设置使用前面的语句所选中的元素的内容，而attr()可以获取和设置单个元素的属性。</p>

<p>html()这个方法能够获取元素或一组元素的HTML内容，它类似于JavaScript的innerHTML：</p>

<pre><code>var htmlContent = $(&quot;#elem&quot;).html(); //变量htmlContent就会包含id为&quot;elem&quot;的页面元素内部的全部HTML (包括文本)。
</code></pre>

<p>使用类似的语法，就可以设置元素或一组元素的HTML内容：</p>

<pre><code>$(&quot;#elem&quot;).html(&quot;&lt;p&gt;Here is some new content.&lt;/p&gt;n); //这样就会修改id为“elem”的页面元素的HTML内容
</code></pre>

<p>text()如果只是想获得一个元素或一组元素的文本内容，除了使用html()外，还可以使用text()：</p>

<pre><code>var textcontent = $(&quot;#teim&quot;)*text(); //变量textcontent就会包含id为&quot;elem&quot;的页面元素内部的全部文本(不包括HTML)。
</code></pre>

<p>同样地，它也可以设置元素的文本内容：</p>

<pre><code>$(&quot;#elem&quot;).text (&quot;Here is some new content.&quot;)； //这样就会修改id为&quot;elem&quot;的页面元素的文本内容。
</code></pre>

<p>如果想给元素添加文本内容而不是替换其中的内容，可以这样做：</p>

<pre><code>$(&quot;#elem&quot;).append(&quot;&lt;p&gt;Here is some new content.&lt;/p&gt;&quot;); //这样会在保持原有内容的基础上，添加新的内容。
</code></pre>

<p>类似地：
    $(&ldquo;div&rdquo;).append(&rdquo;<p>Here is some new content.</p>&rdquo;); //会给页面上全部<div>元素添加一些内容.</p>

<p>attr()当应用于一个元素时，这个方法返回特定属性的值。</p>

<pre><code>var titie = $(&quot;#elem&quot;).attr(&quot;title&quot;);
</code></pre>

<p>如果应用于一组元素，它只返回第一个元素的值,利用这个方法还可以设置属性的值：</p>

<pre><code>$(&quot;#elem&quot;).attr(&quot;title&quot;,&quot;This is the new title&quot;);
</code></pre>

<p><strong>附加：</strong></p>

<p>val() 方法返回或设置被选元素的值。元素的值是通过 value 属性设置的。其中有部分元素没有value，该方法大多用于 input 元素。如果该方法未设置参数，则返回被选元素的当前值。</p>

<pre><code>$(&quot;#name&quot;).val()     //获取id=&quot;name&quot;的value值
$(&quot;#name&quot;).val(value)  //为id=&quot;name&quot;的元素的value赋值，value表示你赋予的值
</code></pre>

<p>html()方法返回或设置被选元素的内容(innerHTML)。如果该方法未设置参数，则返回被选元素的当前内容。当使用该方法返回一个值时，它会返回第一个匹配元素的内容。当使用该方法设置一个值时，它会覆盖所有匹配元素的内容。</p>

<pre><code>$(&quot;#name&quot;).html() //获取第一个id=name的内容
$(&quot;#name&quot;).html(&quot;需要赋予的值&quot;) 
</code></pre>

<p>attr() 方法设置或返回被选元素的属性值。根据该方法不同的参数，其工作方式也有所差异。</p>

<pre><code>$(&quot;name&quot;).attr(&quot;attribute&quot;); //返回被选元素的属性值。
$(&quot;name&quot;).attr(attribute,value)； //设置被选元素的属性和值。
</code></pre>

<p>区别：
+ val()一般用在input上，val主要运用于表单元素上，而不用在其他元素，用来获取input或者是select的值（但我用val给select赋值时无法显示，不知道为什么）。
+ html()和text()、attr()可用在多种元素上，但是html()相当于依据源代码返回，也就是在返回的内容中会包含各种tag，而text()则相当于是依据页面显示返回，返回的内容是出去各种tag之间的内容。</p>

<h3 id="显示和隐藏元素">显示和隐藏元素</h3>

<p>对于传统的JavaScript来说，显示和隐藏页面元素通常是利用元素style对象的display或visibility属性来实现的。这种方法没有什么问题，但通常会导致比较长的代码：</p>

<pre><code>document.getElementByTd(&quot;elem”).style.visibility = 'visible';
</code></pre>

<p>利用jQuery的show()和hide()方法就可以只用较短的代码实现相同的功能，而且还具有额外一些功能。</p>

<p>show()方法可以让单个元素或一组元素显示在页面上：</p>

<pre><code>$(&quot;div&quot;).show();    //显示全部&lt;div&gt;元素
</code></pre>

<p>另外，还可以添加一些参数来调整显示的过程。在下面的范例里，第一个参数&rdquo;fast&rdquo;决定了显示元素的速度。这个参数除了可以设置为fast或slow外，还可以用数字表示特定时间(单位是毫秒)。如果不设置这个参数，元素就会立即显示，没有任何动画。slow对应的数值大约是600毫秒，fast对应的数值大约是200毫秒。</p>

<p>hide()方法的用途显然与show()是相反的，用于隐藏页面元素。它也有一些和show()一样的可选参数：</p>

<pre><code>$ (&quot;#elem&quot;) .hide (&quot;slow&quot;, function () {
//在元素隐藏之后进行某些操作
});
</code></pre>

<p>toggle()方法会改变一个元素或一组元素的当前显示状态，也就是说把处于显示状态 的元素隐藏起来，把处于隐藏状态的元素显示出来。它也具有关于变化速度及回调函数的参数。</p>

<pre><code>$(&quot;#elemn&quot;).toggle(1000, function() {
/ / 在元素显示或隐藏之后进行某些操作
})；
</code></pre>

<p>show()、hide()和 toggle()方法都可以应用于一组元素，这些元素会同时显示或隐藏。</p>

<h3 id="元素动画">元素动画</h3>

<h4 id="淡入淡出">淡入淡出</h4>

<p>在实现元素淡入淡出的同时，还可以设置持续时间和回调函数。淡出的操作是这样的：</p>

<pre><code>$ (&quot;#elem&quot;).fadeOut(&quot;slow&quot;,function() {
/ / 在淡出之后进行一些操作
})；
</code></pre>

<p>淡入的操作是这样的：</p>

<pre><code>$(&quot;#elem&quot;).fadein(500,function() {
/ / 在淡入之后进行一些操作
})；
</code></pre>

<p>还可以让元素只进行部分淡入或淡出：</p>

<pre><code>$ (&quot;#elemn&quot;).fadeTo(3000, 0.5, function() {
/ / 在淡入或淡出之后进行一些操作
});
</code></pre>

<p>其中第二个参数(本例是0.5)表示最终的不透明度，类似于CSS里设置的不透明度。不管元素曾经的不透明度是多少，在执行上述语句之后，它都会变成第二个参数所指定的值。</p>

<h4 id="滑动">滑动</h4>

<p>jQuery实现元素滑动的方法与实现淡入淡出的方法如出一辙，它们的参数具有同样的规 则，可以实现单个或一组元素的向上或向下滑动。</p>

<pre><code>$(&quot;#elem&quot;).slideDown(150, function(){
/ / 向下滑动之后进行一些操作
})；
</code></pre>

<p>向上滑动是这样的：</p>

<pre><code>$(&quot;#elem&quot;).slideUp(&quot;slow&quot;,function() {
//向上滑动之后进行一些操作
})；
</code></pre>

<p>为了实现根据元素目前位置自动决定是向上滑动还是向下滑动，jQuery还提供了slideToggle()方法。</p>

<pre><code>$(&quot;#elem&quot;).slideToggle(1000, function () {
/ / 向上或向下滑动之后进行一些操作
})；
</code></pre>

<h4 id="动画">动画</h4>

<p>实现动画的方法很简单，利用jQuery指定元素要使用CSS样式表。jQuery就以渐变方式应用新的CSS样式(而不是像普通的CSS或 JavaScript那样直接应用)，从而实现动画的效果。animate()方法可以应用于很多CSS属性。下面的范例中把元素的宽度和高度动画到400 像素x500像素，并且在动画完成之后，利用回调函数把元素淡出为隐藏:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1{
            width: 200px;
            height: 200px;
            border:5px solid red;
        }
    &lt;/style&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function demo() {
            $(&quot;#div1&quot;).animate(
                    {
                        width: &quot;400px&quot;,
                        height: &quot;500px&quot;
                    }, 1500, function () {
                        $(this).fadeOut(&quot;slow&quot;);
                    }
                );
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;input id=&quot;input1&quot; type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;demo()&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="命令链">命令链</h3>

<p>jQuery的大多数方法都返回一个jQuery对象，它可以用于再调用其他方法，这是jQuery 的另一个方便之处。比如可以像这样组合前面的范例：</p>

<pre><code>$(&quot;#elem&quot;).fadeOut().fadein();
</code></pre>

<p>上面这行代码会先淡岀指定的元素，然后淡入显示它们。命令链的长度没有什么限制, 从而可以对同一组元素连续进行很多操作：</p>

<pre><code>$(&quot;#elem&quot;).text(&quot;Hello from jQuery&quot;).fadeOut().fade1n();
</code></pre>

<p>页面加载之后应该显示一个红色<div>元素，具有黑色边框，其中内容是“改变形状&hellip;.”，在动画变化为新的宽度和高度之后，其中的内容会变为&rdquo;褪色&hellip;”，并且整个元素淡出消失。示例：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #animateMe {
            position: absolute;
            width: 100px;
            height: 400px;
            top: 100px;
            Left: 100px;
            border: 2px solid black;
            background-color: red;
            padding: 20px;
        }
    &lt;/style&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        $(document).ready(function () {
            $(&quot;#animateMe&quot;).text(&quot;改变形状...&quot;).animate(
            {
                width: &quot;400px&quot;,
                height: &quot;200px&quot;
            }, 5000, function () {
                $(this).text(&quot;褪色...&quot;).fadeOut(4000);
            }
        );
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;animateMe&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="处理事件">处理事件</h3>

<p>在jQuery里可以用多种方式给单个元素或一组元素添加事件处理器。首先，最直接的方法是这样的：</p>

<pre><code>$(&quot;a&quot;).click(function() {
/ / 当锚点元素被单击时要执行的代码
})；
</code></pre>

<p>或者像下面这样使用命名的函数：</p>

<pre><code>function hello(){
    alert(n Hello from jQuery&quot;);
}
$(&quot;a&quot;).click(hello);
</code></pre>

<p>在上面这两个范例里，当锚点被单击时，就会执行指定的函数。jQuery里其他常见的事件包括</p>

<ul>
<li>blur：当元素失去焦点时发生。</li>
<li>focus：当元素获得焦点时发生。</li>
<li>hover：当鼠标指针悬停在被选元素上时发生。</li>
<li>keypress：键被按下时发生。</li>
<li>keydown：键按下的过程。</li>
<li>keyup：键被松开。</li>
<li>change：当元素的值发生改变时触发事件,该事件仅适用于文本域(text field)，以及textarea和select 元素。</li>
<li>mousemove：当鼠标指针在指定的元素中移动时,<code>$(document).mousemove(function(e){$(&quot;span&quot;).text(e.pageX + &quot;, &quot; + e.pageY);});)</code>。</li>
<li>resize：当调整浏览器窗口大小时发生。</li>
<li>scroll：当用户滚动指定的元素时会发生，scroll 事件适用于所有可滚动的元素和 window 对象（浏览器窗口）。</li>
<li>submit：当提交表单时，会发生的事件。该事件只适用于表单元素。</li>
<li>select：当 textarea 或文本类型的 input 元素中的文本被选择（标记）时，会发生 select 事件。</li>
</ul>

<p>jQuery以跨浏览器的方式包装了attachEvent和 addEventListener方法，从而便于添加多个事件处理器：</p>

<pre><code>$(&quot;a&quot;).on ('click',hello);
</code></pre>

<p>on()方法是在jQuery 1.7引入的，用于取代以前一些事件处理方法，包括 bind()、delegate()和 live()。on()方法可以给原本存在于HTML页面的元素或者动态添加DOM的元素添加处理器。</p>

<h3 id="小结-1">小结</h3>

<p>jQuery是功能强大且非常流行的JavaScript库，它具有很容易使用的API,可以在广大的主流的浏览器中工作。jQuery由JohnResig编写，发布于2006年。目前有多个jQuery项目，包括jQuery Core(上面的介绍)和jQuery UI(后面有所介绍)。这些项目都处于活跃的开发状态，由John和一个志愿者小组进行维护。关于这些项目及开发小组的情况可以参考jquery.orgo。jQuery可以与其他库同时使用。它提供了 jQuery.noConflict()方法来避免冲突, 详情请见 <a href="http://docs.jquery.com/Using_jQuery_with_Other_Libraries">http://docs.jquery.com/Using_jQuery_with_Other_Libraries</a>。</p>

<h2 id="jquery-ui">jQuery UI</h2>

<p>jQuery UI提供了很多高级效果和主题微件，可以帮助我们建立互动的Web应用。</p>

<h3 id="jquery-ui-是什么">jQuery UI 是什么</h3>

<p>jQuery开发小组决定提供一个”官方“的jQuery插件集合，集中大量流行的用户界面组 件，并且赋予它们统一的界面风格。利用这些组件，只用少量的代码就可以建立高度交互且
样式迷人的Web应用。
jQuery U I为我们提供了：</p>

<ul>
<li>交互性。jQuery UI支持对页面元素进行拖放、调整尺寸、选择和排序。</li>
<li>微件。这些功能丰富的控件包括可折叠控件、自动完成、按钮、日期拾取器、对话框、进度条、滑动条和选项卡。</li>
<li>主题。让站点在全部用户界面组件都具有一致的观感。从<a href="http://jqueryui.com/themeroller">http://jqueryui.com/themeroller</a>上下载ThemeRoller工具，它可以从预先设置的很多设计中选择主题，也可以根据现有主题创建定制的主题。</li>
</ul>

<p>由于jQuery U I具有出色的用户界面一致性，利 用jQuery文档，可以轻松地查看很多其他可用的插件。</p>

<h3 id="如何在页面里引用jquery-ui">如何在页面里引用jQuery UI</h3>

<p>第一步是访问<a href="http://jqueryui.com/themeroller/">http://jqueryui.com/themeroller/</a>的jQuery ThemeRoller在线应用。</p>

<h4 id="使用-themeroller">使用 ThemeRoller</h4>

<p>jQuery UI CSS框架是一组类，满足了相当大范围的用户界面需求。利用ThemeRoller 工具，我们就可以从无到有建立自己的样式，或是基于<a href="http://jqueryui.com/themeroller/Jl供的大">http://jqueryui.com/themeroller/Jl供的大</a>
量范例来实现自己的样式。</p>

<p>在确定了样式之后，jQuery UI会提供一个可下载的构造器，其中包含了我们所需要的组件。它还会处理关于文件依赖的问题，避免下载的微件或交互缺少支持文件。我们需要做的只是下载和解压这个压缩文件。文件解压缩之后，会得到如下的目录结构：</p>

<pre><code>/css/
/development-bundle/
/js/
</code></pre>

<p>development-bundle目录保存了 jQuery UI源代码、范例和文档。如果不需要修改jQuery UI代码，把这个目录删除就可以了，不会有什么问题。一般来说，我们需要在使用jQuery UI微件和交互的页面里从剩余的其他文件中引用主题以及jQuery和jQuery UI：</p>

<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;jquery-ui-min.css&quot; /&gt;
&lt;script src=&quot;http://code.jquery.com/jquery-latest.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://codeorigin.jquery.com/ui/1.10.3/jquery-ui.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>如果是使用标准范例的主题，就可以利用CDN链接全部这些文件：</p>

<p><link rel="tylesheet" type="text/css" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/themes/smoothness/jquery-ui.css"/>
<script src="http://code.jquery.com/jquery-latest.min.j sMx</script>
<script src="http://codeorigin.jquery.com/ui/1.10.3/jquery-ui.min.js"></script></p>

<p>个人从官网示例找到的是：</p>

<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
&lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
</code></pre>

<h3 id="交互">交互</h3>

<p>jQuery UI能做一些事情来改善页面元素与用户的交互。</p>

<h4 id="拖和放">拖和放</h4>

<p>使用jQuery UI让一个元素成为能够拖放得再简单不过了,示例：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;
        #dragdiv {
            width: 100px;
            height: 100px;
            background-color: #eeffee;
            border: 1px solid black;
            padding: 5px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        $(function () {
            $(&quot;#dragdiv&quot;).draggable(); //设置元素可以拖放
        });
    &lt;/script&gt;    
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;dragdiv&quot;&gt; 这个元素可以在页面上拖放！!&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>利用jQuery UI实现元素的拖和放 为了让某个元素能够接受拖放到它的另一个元素，需要使用droppable()方法。这个方法可以指定用于多个事件，比如可拖动元素被放下、经过可拖动区域或离开可拖动区域。除了要让拖动元素成为可拖动的，还需要把这个新的<code>&lt;div&gt;</code>元素指定为可放置区域,另外，我们给drop和 out事件处理器添加方法，让拖动元素里的文本在它被放下或离开 放置区域时有相应的变化。示例：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;
        div {
            font: 12px normal arial, helvetica;
        }
        #dragdiv {
            width: 150px;
            height: 50px;
            background-color: #eeffee;
            border: 1px solid black;
            padding: 5px;
        }
        #dropdiv {
            position: absolute;
            top: 80px;
            left: 100px;
            width: 300px;
            height: 200px;
            border: 1px solid black;
            padding: 5px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        $(function () {
            $('#dragdiv').draggable();
            $('#dropdiv').droppable({
                drop: function() { $ ('#dragdiv') .text (&quot;已放下！&quot;);},
                out: function () { $(&quot;#dragdiv&quot;).text(&quot;再次拿起来！&quot;); }
            });
        });
    &lt;/script&gt;    
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;dropdiv&quot;&gt; 这里是放下来的区域！&lt;/div&gt;
    &lt;div id=&quot;dragdiv&quot;&gt;在页面内拖动此元素！&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="调整大小">调整大小</h4>

<p>使用jQueryUI给矩形元素添加调整大小的手柄也是很容易的:</p>

<pre><code>$('#resizable').resizable();
</code></pre>

<p>作为一个示范，我们可以把上面的放置区域以命令链的形式添加resizable()方法:</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;
        div {
            font: 12px normal arial, helvetica;
        }
        #dragdiv {
            width: 150px;
            height: 50px;
            background-color: #eeffee;
            border: 1px solid black;
            padding: 5px;
        }
        #dropdiv {
            position: absolute;
            top: 80px;
            left: 100px;
            width: 300px;
            height: 200px;
            border: 1px solid black;
            padding: 5px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        $(function () {
            $('#dragdiv').draggable();
            $('#dropdiv').droppable({
                drop: function() { $ ('#dragdiv') .text (&quot;已放下！&quot;);},
                out: function () { $(&quot;#dragdiv&quot;).text(&quot;再次拿起来！&quot;); }
            }).resizable();
        });
    &lt;/script&gt;    
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;dropdiv&quot;&gt; 这里是放下来的区域！&lt;/div&gt;
    &lt;div id=&quot;dragdiv&quot;&gt;在页面内拖动此元素！&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="排序">排序</h4>

<p>使用sortable()方法可以把元素添加到列表，并且让列表可以进行排序:</p>

<pre><code>$(&quot;#sortMe&quot;).sortable();
</code></pre>

<p>下面的示例展示了如何对一个无序列表元素使用这个方法：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        $(function () {
            $(&quot;#sortMe&quot;).sortable();
        });
    &lt;/script&gt;    
&lt;/head&gt;
&lt;body&gt;
    &lt;ul id=&quot;sortMe&quot;&gt;
        &lt;li&gt;我是一&lt;/li&gt;
        &lt;li&gt;我是二&lt;/li&gt;
        &lt;li&gt;我是三&lt;/li&gt;
        &lt;li&gt;我是四&lt;/li&gt;
        &lt;li&gt;我是五&lt;/li&gt;
    &lt;/ul&gt;
    &lt;span&gt;列表元素可拖动！&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="使用微件">使用微件</h3>

<p>微件是一种界面元素，在提供方便功能的同时，对于程序的影响保持在最小程度。</p>

<h4 id="可折叠控件">可折叠控件</h4>

<p>可折叠控件让用户在一组div元素里可以一次只展开一个，而其他的保持在只显示标题的状态。首先需要在语义层添加数据，方法是使用多个标题和内容窗格：</p>

<pre><code>&lt;div id='accordion'&gt;
&lt;h3&gt;&lt;a href=&quot;&quot;&gt;First header&lt;/a&gt;&lt;/h3&gt; 
&lt;div&gt; First content&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;#&quot;&gt;Second header&lt;/a&gt;&lt;/h3&gt; 
&lt;div&gt;Second content&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>然后在外层容器元素上调用accordionO方法来激活折叠控件：</p>

<pre><code>&lt;script&gt;
    $(function () {
        $(&quot;#accordion&quot;).accordion();
    });
&lt;/script&gt;
</code></pre>

<p>下面是个示例，展示一家餐馆的午餐菜品在折叠控件的不同部分展示：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        $(function () {
            $(&quot;#accordion&quot;).accordion();
        });
    &lt;/script&gt;    
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;从下列菜单选项中选择：&lt;/h2&gt;
    &lt;div id=&quot;accordion&quot;&gt;
        &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;开胃小吃&lt;/a&gt;&lt;/h3&gt; 
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;蛤蜊浓汤&lt;/li&gt;
                &lt;li&gt;火腿鳄梨沙拉&lt;/li&gt;
                &lt;li&gt;填馅蘑菇&lt;/li&gt;
                &lt;li&gt;鸡肝酱&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt; 
        &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;主食&lt;/a&gt;&lt;/h3&gt; 
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;苏格兰鲑鱼&lt;/li&gt;
                &lt;li&gt;蔬菜千层面&lt;/li&gt;
                &lt;li&gt;牛肉肾馅饼&lt;/li&gt;
                &lt;li&gt;烤鸡&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt; 
        &lt;h3&gt;&lt;a href=&quot;#&quot;&gt;饭后甜点&lt;/a&gt;&lt;/h3&gt; 
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;巧克力圣代&lt;/li&gt;
                &lt;li&gt;柠檬冰沙&lt;/li&gt;
                &lt;li&gt;水果沙拉&lt;/li&gt;
                &lt;li&gt;草莓芝士蛋糕&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="日期拾取器">日期拾取器</h4>

<p>假设下面这个字段是要输入日期的：</p>

<pre><code>&lt;input type=&quot;text&quot; id=&quot; datepicker&quot; /&gt;
</code></pre>

<p>只需一行代码就可以给这个字段添加日期拾取器：</p>

<pre><code>$(function () {
        $(&quot;#datepicker&quot;).datepicker();
    });
</code></pre>

<h4 id="选项卡">选项卡</h4>

<p>要达到这种节省空间的目的除了可折叠控件，还有另一种方法，就是使用选项卡界面。示例：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        $(function () {
            $(&quot;#tabs&quot;).tabs();
        });
    &lt;/script&gt;    
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;tabs&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#tabs-1&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#tabs-2&quot;&gt;About Us&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#tabs-3&quot;&gt;Products&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt; 
        &lt;div id=&quot;tabs-1&quot;&gt;
            &lt;p&gt;Welcome to our online store....&lt;/p&gt;
        &lt;/div&gt; 
        &lt;div id=&quot;tabs-2&quot;&gt;
        &lt;p&gt;We've been selling widgets for 5 years ...&lt;/p&gt;
        &lt;/div&gt; 
        &lt;div id=&quot;tabs-3&quot;&gt;
            &lt;p&gt;We sell all kinds of widgets ...&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="小结-2">小结</h3>

<p>本章介绍了如何利用jQuery UI配合jQuery建立灵活的用户界面，如何利用ThemeRoller应用设置界面元素的整体风格，可以看到给页面添加交互和微件是多么地轻松。我们还能对界面元素进一步定制，这里介绍的界面和微件都使用了它们的默认设置，而它们实际上有大量的定制选项，可以根据我们的需要进行设置。<a href="http://docs.jquery.com/UI/提供了大量的文档和范例。">http://docs.jquery.com/UI/提供了大量的文档和范例。</a></p>

<p>让页面上的其他元素与jQuery UI生成的元素具有同样的样式：当jQuery U I生成装饰效果时，它会把很多的类应用于新创建的元素。这些类对应 于jQuery UI CSS框架里的CSS声明。每一个微件的详细说明请见jQuery UI文档。</p>

<h2 id="ajax-和-jquery">Ajax 和 jQuery</h2>

<p>Ajax是什么，它如何提高用户体验：</p>

<p>Ajax是 Asynchronous JavaScript And XML的缩写。实际上，Ajax并不仅限于只是返回XML数据。JavaScript是客户端脚本语言，本书前面介绍的全部范例都是客户端编程。Ajax允许与后台的服务器通信，并且不需要执行页面刷新就能够将结果显示到页面上。这就使得你能够创建与用户平滑交互的页面。在本章中，我们将学习支持Ajax的底层技 术，以及如何使用jQuery使得整个过程漂亮而简单。</p>

<h3 id="ajax解析">Ajax解析</h3>

<p>到目前为止，我们介绍的都是关于站点用户界面的传统页面模型。在用户与这种站点互动时，每个页面包含文本、图像、数据输入表单等，依次展现。每个页面都得单独处理，才能跳转到下一个页面。举例来说，在填写表单的字段时，我们会根据需要进行编辑，因为知道在最终提交之前，数据不会被发送到服务器。</p>

<p><img src="https://SLTaurus.github.io/images/JavaScript/JavaScript25.jpg" alt="JavaScript25" /></p>

<p>上面的图展示了这种互动过程。在提交表单或单击链接之后，浏览器要进行屏幕刷新,才能显示由服务器发送的新页面或修改后的页面。符合这种模型的交互具有一些缺点。首先，每个新页面或修改页面的加载都会有明显延时，这会影响用户对于应用程序“流畅”运行的感觉。而且，即使新页面与前一个页面的内容几乎是相同的，每次也都需要加载“整个”页面。站点里很多页面的共同元素，比如标题、面脚、导航栏，可能会在页面数据里占据很大的比例。这种不必要的数据下载会浪费带宽，而且会使每个新页面的加载延时恶化。</p>

<p>我们希望耗时的计算过程在后台安静地运行，而显示内容仍然保留在屏幕上，界面元素依旧能对用户的指令产生响应。</p>

<h4 id="ajax-入门">Ajax 入门</h4>

<p>Ajax能够实现上述在桌面应用程序中很常见的功能，它在Web页面与服务器之间建立了 一个额外的“处理层”。</p>

<p>这个“处理层”通常称为Ajax引擎或Ajax框架。它解释来自用户的请求，在后台以异步方式“安静”地处理服务器通信。这意味着对于用户操作,服务器请求与响应不再需要同步一致了，而只是在便于用户使用或程序正确操作需要时才发生；浏览器不会停止响应来等服务器完成对最后一个请求的处理，而是会允许用户在当前页面浏览、单击和输入数据。页面上需要根据服务器响应进行修改的元素也由Ajax 处理，这是在页面保持可用状态过程中动态进行的。下图这种交互方式的示意。
<img src="https://SLTaurus.github.io/images/JavaScript/JavaScript26.jpg" alt="JavaScript26" /></p>

<h4 id="xmlhttprequest对象">XMLHttpRequest对象</h4>

<p>当用户单击页面上的链接或是提交一个表单时，就向服务器发送了一个HTML请求，得到的响应是一个新页面或修改过的页面。然而，为了能让Web程序实现异步工作，必须使用一种方式给服务器发送HTTP请求而不必显示新页面。</p>

<p>利用XMLHttpRequest对象就可以实现这种方式。它能够建立与服务器的连接，发送HTTP请求而不需要加载相应的页面。出于安全的考虑，XMLHttpRequest对象一般只能调用与当前页面同一个域里的URL,而不能直接调用远程服务器。</p>

<h4 id="不同浏览器的不同规则">不同浏览器的不同规则</h4>

<p>对于大多数本身支持XMLHttpRequest对象的浏览器(比如Firefox、Opera以及较新版本的IE)来说，创建它的实例是很直接的，比如下面这条语句就会创建名为request的实例：</p>

<pre><code>var request = new XMLHttpRequest();
</code></pre>

<p>在一些早期版本的IE里，为了达到同样的目的，需要创建一个ActiveX对象，如下所示:</p>

<pre><code>var request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
</code></pre>

<p>与前面一样，这也是把新对象的名称设置为requesto更复杂的是，有些IE版本安装了不同版本的XML解析器，这时就要使用如下的指令：</p>

<pre><code>var request = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
</code></pre>

<h4 id="方法和属性">方法和属性</h4>

<p>在创建了 XMLHttpRequest对象之后，现在来看看它的属性和方法，如下表所示：</p>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">onreadystatechange</td>
<td align="left">当对象的readyState属性改变时，调用哪个事件处理器</td>
</tr>

<tr>
<td align="center">readyState</td>
<td align="left">以整数形式反映请求的状态，0=未初始化，1=正在加载，2=加载完成，3=交互，4=完成。</td>
</tr>

<tr>
<td align="center">responseText</td>
<td align="left">以字符串形式从服务器返回的数据</td>
</tr>

<tr>
<td align="center">responseXML</td>
<td align="left">以文档对象形式从服务器返回的数据</td>
</tr>

<tr>
<td align="center">status</td>
<td align="left">服务器返回的HTTP状态代码</td>
</tr>

<tr>
<td align="center">statusText</td>
<td align="left">服务器返回的解释短语</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">abort()</td>
<td align="left">停止当前请求</td>
</tr>

<tr>
<td align="center">getAllResponseHeaders()</td>
<td align="left">以字符串形式返回全部标题</td>
</tr>

<tr>
<td align="center">getResponseHeader(x)</td>
<td align="left">以字符串形式返回标题X的值</td>
</tr>

<tr>
<td align="center">open(&lsquo;method&rsquo;,&lsquo;URL&rsquo;, &lsquo;a&rsquo;)</td>
<td align="left">指定HTTP方法（GET或POST）、目标URL和处理请求的方式（a=true, 默认，表示异步；a=false，表示同步）</td>
</tr>

<tr>
<td align="center">send(content)</td>
<td align="left">发送请求。对于POST数据是可选的</td>
</tr>

<tr>
<td align="center">setRequestHeader(&lsquo;x&rsquo;,&lsquo;y&rsquo;)</td>
<td align="left">设置“参数=值”对（x=y）, 把它赋予与请求一起发送的标题</td>
</tr>
</tbody>
</table>

<p>使用这些方法和属性建立函数，最终构成我们的Ajax程序。</p>

<h4 id="与服务器通信">与服务器通信</h4>

<p>在传统的Web页面中，当你通过一个超链接或一次表单提交发送了一个服务器请求，服务器接受该请求，执行所需的任何服务器端过程，并且随后为你提供一个新的页面，其中带有与你所执行的操作相对应的内容。当这个过程发生的时候，用户界面实际上是冻结的。当服务器完成其任务的时候，你会看到浏览器中好像有了一个全新的或重新访问的页面。</p>

<p>然而，对于异步的服务器请求，这样的通信实际上是在后台发生的，请求的完成并不一定要和屏幕刷新或新页面的加载同步进行。因此，必须想其他办法才能搞清楚服务器如何处理你的请求。XMLHttpRequest对象有一个方便的属性，能够报告服务器请求的进程。你可以使用JavaScript程序来查看这个属性，以判定服务器完成其任务到了哪一步了，并且结果也是可供你使用的。因此，Ajax应用必须包含一个程序来监控请求的状态并执行相应的操作。</p>

<h4 id="在服务器端发生了什么">在服务器端发生了什么</h4>

<p>对于服务器端脚本来说，来自XMLHttpRequest对象的通信只不过是另一个HTTP请求而已。街ax应用程序对于服务器端是何种语言或操作环境知之甚少。只要客户端Ajax层接受到来自服务器的及时的、格式正确的HTTP请求，就可以了。</p>

<h4 id="处理服务器响应">处理服务器响应</h4>

<p>一旦注意到一个异步请求已经成功地完成了，你就可以使用服务器所返回的信息了。Ajax允许这些信息以多种格式返回给你，包括ASCII文本和XML数据。根据应用程序的特性，你可以随后在当前页面之中转换、显示或处理这些信息。还有更容易的方法，不是吗？好在，有很多的JavaScript库做了很好的工作，将这些相当复杂的过程包装到易于使用的函数和方法之中。在下面我们将看到jQuery库是如何使得编写Ajax脚本 变得很轻松容易的。</p>

<h3 id="使用jquery实现ajax">使用jQuery实现Ajax</h3>

<p>由于不同浏览器以不同方式实现XMLHttpRequest对象，Ajax编程显得有些复杂。好在jQuery解决了这些问题，让我们可以用很少的代码就可以编写Ajax程序。jQuery包含不少执行Ajax对服务器调用的方法，这里介绍其中最常用的一些。</p>

<p>如果只是需要从服务器获取一个文档并在页面元素里显示它，那么只需要使用load()方法就可以了。比如下面的代码段会获取newContent.html,并且把它的内容添加到id为&rdquo;elem&rdquo;的元素：</p>

<pre><code>$(function () {
        $(&quot;#elem&quot;).load(&quot;newContent.html&quot;);
    });
</code></pre>

<p>在使用load()方法时，除了指定URL外，还可以传递一个选择符，从而只返回相应的页面内容：</p>

<pre><code>$(function () {
        $(&quot;#elem&quot;).load(&quot;newContent.html #info&quot;);
    });
</code></pre>

<p>上面的范例在URL之后添加了一个jQuety选择符，中间以空格分隔。这样就会返回选择符指定的容器里的内容，本例中，就是id为&rdquo;info&rdquo;的元素。后面的可选的callback参数规定当load()方法完成后所要允许的回调函数。回调函数可以设置不同的参数：</p>

<ul>
<li>responseTxt - 包含调用成功时的结果内容</li>
<li>statusTXT - 包含调用的状态</li>
<li>xhr - 包含 XMLHttpRequest 对象</li>
</ul>

<p>下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示“外部内容加载成功！”，而如果失败，则显示错误消息：</p>

<pre><code>$(&quot;button&quot;).click(function(){
$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){
    if(statusTxt==&quot;success&quot;)
    alert(&quot;外部内容加载成功！&quot;);
    if(statusTxt==&quot;error&quot;)
    alert(&quot;Error: &quot;+xhr.status+&quot;: &quot;+xhr.statusText);
});
});
</code></pre>

<p>如果是从表单字段获取数据,jQuery还提供了serialize()方法，能够对表单 数据进行序列化：</p>

<pre><code>var formdata = $('#forml').serialize(); 
</code></pre>

<p>为了弥补load()方法的简单功能，jQuery还提供了发送GET和POST请求的方法。这两个方法很类似，只是调用不同的请求类型而已。调用这两个方法时，不需要选择某个jQuery对象(比如某个或一组页面元素)，而是直接调用：$.get()或$.post()在最简单的形式中，它们只需要一个参数，就是目标URL。通常情况下，我们还需要发送一些数据，它们是以&rdquo;参数/值&rdquo;对的形式出现的，以JSON风格的字符串作为数据格式。</p>

<p>大多数情况下，我们会对返回的数据进行一些处理，为此还需要把回调函数作为参数:</p>

<pre><code>$.get(&quot;serverScript.php&quot;,
        { paraml: &quot;valuel&quot;, param2: &quot;nvalue2&quot; },
        function (data) {
            alert(&quot;Server responded: &quot; + data);
        });
</code></pre>

<p>post()方法的语法基本上是相同的：</p>

<pre><code> $.post(&quot;serverScript.php&quot;,
        { paraml: &quot;valuel&quot;, param2: &quot;nvalue2&quot; },
        function (data) {
            alert(&quot;Server responded: &quot; + data);
        });
</code></pre>

<p>ajax()方法具有很大的灵活性，几乎可以设置关于Ajax调用及如何处理响应的各个方面。详细的介绍请见 <a href="http://api.jquery.com/jQuery.ajax/的文档。">http://api.jquery.com/jQuery.ajax/的文档。</a></p>

<p>用jQuery实现简单的Ajax表单提交,并实现如下操作：</p>

<ul>
<li>检查并确保两个输入字段都有内容。</li>
<li>利用HTTP POST通过Ajax提交表单。</li>
<li>使服务器返回的数据显示在页面的<div>元素里。</li>
</ul>

<p>为了检查两个输入字段都有内容，只需要使用如下的函数：</p>

<pre><code>function checkFields(){ 
            return ($(&quot;#name&quot;).val() &amp;&amp; $ (&quot;#email&quot;).val());
        }
</code></pre>

<p>当两个输入字段的value属性都包含一些文本时，这个函数才会返回true,只要有任何一 个字段是空的，空字段就会解释为false,而 false的逻辑“与”操作的结果一定是false。</p>

<p>接下来，利用jQuery的submit()事件处理器检测表单提交动作。如果函数checkFields()返回false,默认操作是取消提交：如果返回true,jQuery会对数据进行序列化，并且向服务器脚本发送一个post()请求。jQuery的serialize()方法可以获取表单信息，进行序列化，满足Ajax调用的需要。在这个范例中，服务器脚本test.php并没有什么实际操作，只是把它收到的信息调整下格式，以HTML形式返回：</p>

<pre><code>&lt;?php
echo &quot;Name:&quot; . $_REQUEST['name'] . &quot;&lt;br /&gt;Email: &quot; . $_REQUEST['email'];
?&gt;
</code></pre>

<p>程序清单如下：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        $ (document).ready(function(){ 
            function checkFields(){ 
                return ($(&quot;#name&quot;).val() &amp;&amp; $ (&quot;#email&quot;).val());
            }

            $ (&quot;#forml&quot;).submit(function(){ 
                if(checkFields()){ 
                    $.post( 'test.php', $ (&quot;#forml&quot;).serialize(), 
                        function(data){
                        //最后，回调函数在页面上显示返回的内容：
                            $ (&quot;#divl&quot;).html(data);
                        });
                }
                else alert (&quot;Please fill in name and email fields !&quot;); 
                return false;
            });
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;form1&quot;&gt;
        Name：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;&lt;br /&gt; 
        Email ：&lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot;&gt;&lt;br /&gt; 
        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit&quot; value=&quot;提交表单&quot; 〉&gt;
    &lt;/form&gt; 
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>额外示例，通过 AJAX 加载一段文本，test.txt的HTML 代码：</p>

<pre><code>&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;Let AJAX change this text&lt;/h2&gt;&lt;/div&gt;
&lt;button id=&quot;b01&quot; type=&quot;button&quot;&gt;Change Content&lt;/button&gt;
</code></pre>

<p>全部程序清单：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        $(document).ready(function () {
            $(&quot;#b01&quot;).click(function () {
                htmlobj = $.ajax({ url: &quot;/Resources/test.txt&quot;, async: false });
                $(&quot;#myDiv&quot;).html(htmlobj.responseText);
            });
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;通过 AJAX 改变文本&lt;/h2&gt;&lt;/div&gt;
    &lt;button id=&quot;b01&quot; type=&quot;button&quot;&gt;改变内容&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="篇外之一get对比post">篇外之一GET对比POST</h3>

<p>什么是HTTP？超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。HTTP的工作方式是客户机与服务器之间的请求-应答协议。web浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p>

<p>两种最常用的HTTP方法是：GET和POST。GET基本上用于从服务器获得（取回）数据。注释：GET方法可能返回缓存数据。POST也可用于从服务器获取数据。不过，POST方法不会缓存数据，并且常用于连同请求一起发送数据。</p>

<ul>
<li>GET - 从指定的资源请求数据</li>
<li>POST - 向指定的资源提交要处理的数据</li>
</ul>

<p>GET方法，请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p>

<pre><code>/test/demo_form.asp?name1=value1&amp;name2=value2
</code></pre>

<p>有关 GET 请求的其他一些注释：</p>

<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>

<p>POST方法,请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p>

<pre><code>POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre>

<p>有关 POST 请求的其他一些注释：</p>

<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>

<p>比较 GET 与 POST：</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">GET</th>
<th align="left">POST</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">后退按钮/刷新</td>
<td align="left">无害</td>
<td align="left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
</tr>

<tr>
<td align="left">书签</td>
<td align="left">可收藏为书签</td>
<td align="left">不可收藏为书签</td>
</tr>

<tr>
<td align="left">缓存</td>
<td align="left">能被缓存</td>
<td align="left">不能缓存</td>
</tr>

<tr>
<td align="left">编码类型</td>
<td align="left">application/x-www-form-urlencoded</td>
<td align="left">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>
</tr>

<tr>
<td align="left">历史</td>
<td align="left">参数保留在浏览器历史中。</td>
<td align="left">参数不会保存在浏览器历史中。</td>
</tr>

<tr>
<td align="left">对数据长度的限制</td>
<td align="left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>
<td align="left">无限制。</td>
</tr>

<tr>
<td align="left">对数据类型的限制</td>
<td align="left">只允许 ASCII 字符。</td>
<td align="left">没有限制。也允许二进制数据。</td>
</tr>

<tr>
<td align="left">安全性</td>
<td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td align="left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>

<tr>
<td align="left">可见性</td>
<td align="left">数据在 URL 中对所有人都是可见的。</td>
<td align="left">数据不会显示在 URL 中。</td>
</tr>
</tbody>
</table>

<p>其他 HTTP 请求方法:
下面的表格列出了其他一些 HTTP 请求方法：</p>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">HEAD</td>
<td align="left">与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</td>
</tr>

<tr>
<td align="left">PUT</td>
<td align="left">上传指定的 URI 表示。</td>
</tr>

<tr>
<td align="left">DELETE</td>
<td align="left">删除指定资源。</td>
</tr>

<tr>
<td align="left">OPTIONS</td>
<td align="left">返回服务器支持的 HTTP 方法。</td>
</tr>

<tr>
<td align="left">CONNECT</td>
<td align="left">把请求连接转换到透明的 TCP/IP 通道。</td>
</tr>
</tbody>
</table>

<h3 id="篇外之二w3school上面的jquery-ajax-get-和-post-方法诠释">篇外之二W3school上面的jQuery - AJAX get() 和 post() 方法诠释</h3>

<p>jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。两种在客户端和服务器端进行请求-响应的常用方法是：GET 和 POST。</p>

<pre><code>GET - 从指定的资源请求数据
POST - 向指定的资源提交要处理的数据
</code></pre>

<p>GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。</p>

<p>jQuery $.get() 方法通过 HTTP GET 请求从服务器上请求数据。语法：</p>

<pre><code>$.get(URL,callback);
</code></pre>

<p>必需的 URL 参数规定您希望请求的 URL。可选的 callback 参数是请求成功后所执行的函数名。下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：</p>

<pre><code>$(&quot;button&quot;).click(function(){
$.get(&quot;demo_test.asp&quot;,function(data,status){
    alert(&quot;Data: &quot; + data + &quot;\nStatus: &quot; + status);
});
});
</code></pre>

<p>$.get() 的第一个参数是我们希望请求的 URL（&rdquo;demo_test.asp&rdquo;）。第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。提示：这个 ASP 文件 (&ldquo;demo_test.asp&rdquo;) 类似这样：</p>

<pre><code>&lt;%
response.write(&quot;This is some text from an external ASP file.&quot;)
%&gt;
</code></pre>

<p>jQuery $.post() 方法
$.post() 方法通过 HTTP POST 请求从服务器上请求数据。语法：</p>

<pre><code>$.post(URL,data,callback);
</code></pre>

<p>必需的URL参数规定您希望请求的URL。可选的data参数规定连同请求发送的数据。可选的callback参数是请求成功后所执行的函数名。下面的例子使用$.post() 连同请求一起发送数据：</p>

<pre><code>$(&quot;button&quot;).click(function(){
$.post(&quot;demo_test_post.asp&quot;,
{
    name:&quot;Donald Duck&quot;,
    city:&quot;Duckburg&quot;
},
function(data,status){
    alert(&quot;Data: &quot; + data + &quot;\nStatus: &quot; + status);
});
});
</code></pre>

<p>$.post()的第一个参数是我们希望请求的URL(&ldquo;demo_test_post.asp&rdquo;)。然后我们连同请求（name和city）一起发送数据。&rdquo;demo_test_post.asp&rdquo;中的ASP脚本读取这些参数，对它们进行处理，然后返回结果。第三个参数是回调函数。第一个回调参数存有被请求页面的内容，而第二个参数存有请求的状态。</p>

<p>提示：这个 ASP 文件 (&ldquo;demo_test_post.asp&rdquo;) 类似这样：</p>

<pre><code>&lt;%
dim fname,city
fname=Request.Form(&quot;name&quot;)
city=Request.Form(&quot;city&quot;)
Response.Write(&quot;Dear &quot; &amp; fname &amp; &quot;. &quot;)
Response.Write(&quot;Hope you live well in &quot; &amp; city &amp; &quot;.&quot;)
%&gt;
</code></pre>

<h1 id="高级注题">高级注题</h1>

<h2 id="读取和写入cookie">读取和写入cookie</h2>

<p>前面介绍的JavaScript技术还不能把信息从一个页面传递给另一个页面，而cookie提供了一种便捷的方式，能够在用户的计算机上保存少量数据并且远程获得它们，从而让网站可以保存一些细节信息，比如用户的习惯设置或是上一次访问网站的时间。这里将介绍如何使用JavaScript创建、保存、获取和删除cookie。</p>

<h3 id="什么是-cookie">什么是 cookie</h3>

<p>把Web页面加载到浏览器所使用的HTTP是一种“无状态”协议，也就是说，当服务器把页面发送给浏览器之后，它就认为事务完成了，并不保存任何信息。这给在浏览器会话期间（或是在会话之间）维持某种连续性带来了困难，比如记录用户已经访问或下载过哪些内容，或是记录用户在私有区域的登录状态。</p>

<p>cookie就是解决这个问题的一个途径。举例来说，cookie可以记录用户的最后一次访问，保存用户偏好设置的列表，或是当用户继续购物时保存购物车里的物品。在正确使用的情况下，cookie能够改善站点的用户体验。cookie本身是一些短小的信息串，能够由页面保存在用户的计算机上，然后可以被其他 页面读取。cookie 一般都设置为在一定时间后失效。</p>

<p><strong>注意：很多用户不允许站点在自己的计算机上保存cookie,所以在编程时注意不要让站点完全依赖于它们。有人不喜欢cookie,通常的原因是有些站点把cookie作为一种广告手 段，利用它们追踪用户的在线行为，从而进行有针对性的广告。但这也是一 个范例，说明了为什么要使用cookie以及将它用于什么领域。</strong></p>

<h4 id="cookie的局限">cookie的局限</h4>

<p>浏览器对于能够保存的cookie数量有所限制，通常是几百个或多一点。一般情况下，每个域名20个cookies是允许的，而每个域最多能保存4KB的cookie。</p>

<p>除了大小限制可能导致的问题，有很多原因都可能导致硬盘上的cookie消失，比如到达有效期限了，或是用户清理cookie信息了，或是换用其他浏览器了。因此，永远都不应该使用cookie保存重要数据，而且在编写代码时一定要考虑到不能获取所期望cookie时的情况。</p>

<h3 id="document-cookie-属性">document.cookie 属性</h3>

<p>JavaScript使用document对象的cookie属性存储和获取cookie。每个cookie基本上就是一个由成对的名称和值组成的字符串，像下面这样：</p>

<pre><code>username=sam
</code></pre>

<p>当页面加载到浏览器里时，浏览器会收集与页面相关的全部cookie,放到类似字符串的document.cookie属性里。在这个属性里，每个cookie是以分号分隔的：</p>

<pre><code>username=sam;location=USA;status=ful丄member;
</code></pre>

<p><strong>将document.cookie称作&rdquo;类似字符串&rdquo;的属性，因为它并不是真正的字符串，只是在提取cookie信息时，这个属性的表现像个字符串而已。</strong></p>

<h4 id="数据的编码和解码">数据的编码和解码</h4>

<p>某些字符不能在cookie里使用，包括分号、逗号及空白符号（比如空格和制表符）。在把数据存储到cookie之前，需要对数据进行编码，以便实现正确的存储。</p>

<p>在存储信息之前，使用JavaScript的escape()函数进行编码，而获得原始的cookie数据时就使用相应的unescape()函数进行解码。escape()函数把字符串里任何非ASCII字符都转换为相应的2位或4位十六进制格式，比如空格转换为％20, &amp;转换为％26。举例来说，下面的代码会输出变量str里保存的原始字符串及escape()编码以后的结果：</p>

<pre><code>var str = 'Here is a (short) piece of text.'; 
document.write(str + '&lt;br/&gt;' + escape(str));
</code></pre>

<p>其中空格被表示为％20 ,左括号是％28 ,右括号是％29。除了*、@ 、-、_、+、.、/之外的特殊符号都会被编码。</p>

<h3 id="cookie-组成">cookie 组成</h3>

<p>document.cookie里的信息看上去就像是由成对的名称和值组成的字符串，每一对数据的形式是：</p>

<pre><code>name = value;
</code></pre>

<p>但实际上，每个cookie还包含其他一些相关信息，下面来分别介绍。</p>

<p>cookieName和cookieValue就是在cookie字符串里看到的name=value里的名称与值。</p>

<p>domain属性向浏览器指明cookie属于哪个域。这个属性是可选的，在没有指定时，默认值是设置cookie的页面所在的域。这个属性的作用在于控制子域对cookie的操作。举例来说，如果其设置为www.example.com,那么子域code.example.com里的页面就不能读取这个cookie。但如果domain属性设置为example.com,那么code.example.com里的页面就能访问这个cookie了。但是，不能把domain属性设置为页面所在域之外的域。</p>

<p>path属性指定可以使用cookie的目录。如果只想让目录documents里的页面设置cookie的值，就把path设置为/documentso 这个属性是可选的，常用的默认路径是/,表示cookie可 以在整个域里使用。</p>

<p>secure属性是可选的，而且几乎很少使用。它表示浏览器在把cookie发送给服务器时， 是否应该使用SLL安全标准。</p>

<p>expires：每个cookie都有个失效日期，过期就自动删除了。expires属性要以UTC时间表示。如果没有设置这个属性，cookie的生命期就和当前浏览器会话一样长，会在浏览器关闭时自动删除。</p>

<h3 id="编写-cookie">编写 cookie</h3>

<p>要编写新的cookie,只要把包含所需属性的值赋予document.cookie就可以了:</p>

<pre><code>document.cookie = &quot;username=sam;expires=15/06/2013 00:00:00&quot;;
</code></pre>

<p>使用JavaScript的 Date对象可以避免手工输入日期和时间格式：</p>

<pre><code>var cookieDate = new Date ( 2013, 05, 15 ); 
document.cookie = &quot;username=sam;expires=&quot; + cookieDate.toUTCString();
</code></pre>

<p>注意到这里使用了 cookieDate.toUTCString();而不是 cookieDate.toString();, 这是因为cookie的时间要以UTC格式设置。</p>

<p>在实际编写代码时，应该用escape()函数来确保在给cookie赋值时不会有非法字符：</p>

<pre><code>var cookieDate = new Date ( 2013, 05, 15 );         
var user = &quot;Sam Jones&quot;;
document.cookie = &quot;username=&quot; + escape(user) +&quot;; expires=&quot; + cookieDate.toUTCString();
</code></pre>

<h3 id="编写cookie的函数">编写cookie的函数</h3>

<p>很自然就会想到编写一个函数专门用于生成cookie,完成编码和可选属性的组合操作。程序清单如下：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        function createCookie(name, value, days, path, domain, secure) {
            if (days) {
                var date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                var expires = date.toGMTString();
            }
            else
                var expires = &quot;&quot;;
            cookieString = name + &quot;=&quot; + escape(value);
            if (expires)
                cookieString += &quot;; expires=&quot; + expires;
            if (path)
                cookieString += &quot;;path =&quot; + escape(path);
            if (domain)
                cookieString += &quot;; domain=&quot; + escape(domain);
            if (secure)
                cookieString += &quot; secure&quot;;
            document.cookie = cookieString;
        }

        createCookie(&quot;username&quot;, &quot;tom&quot;, 5);
        createCookie(&quot;location&quot;, &quot;USA&quot;, 5);
        createCookie(&quot;status&quot;, &quot;fullmember&quot;, 5);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    Check the cookies for this domain using your browser tools・
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这个函数执行的操作是相当直观的，name和value参数组合得到&rdquo;name=value&rdquo;,其中的value还经过编码以避免非法字符。在处理有效期时，使用的参数不是具体日期，而是cookie有效的天数。函数根据这个天 数生成有效的日期字符串。其他属性都是可选的，如果设置了，就会附加到组成cookie的字符串里。</p>

<p><strong>这个函数每次被调用时，就会给document.cookie设置新值，但新值不会覆盖现有的值，而是把新值附加到原有值。正如前面所说的，document.cookie有时显得像个字符串，但又的确不是字符串。</strong></p>

<h3 id="读取cookie">读取cookie</h3>

<p>读取cookie值的过程在很大程度上是依赖于split()这个函数。split()函数以参数指定的字符作为分隔符，把分解的结果保存到数组里：</p>

<pre><code>myString = &quot;John#Paul#George#Ringo&quot;; 
var myArray = myString.split('#');
</code></pre>

<p>上述语句会把字符串myString在每个&rdquo;#&ldquo;位置进行切割，分解为一系列单独的部分。myArray[0]会保存&rdquo;John&rdquo;，myArray[l]保存&rdquo;Paul&rdquo;，以此类推。在document.cookie里，每个cookie都是以&rdquo;;&ldquo;分隔的，显然我们就应该使用这个符号来分解document.cookie返回的字符串：</p>

<pre><code>var crumbs = document.cookie.split(';');
</code></pre>

<p>我们要获得特定名称的cookie,所以接下来要对数组crumbs进行搜索，得到特定的name=部分。然后使用indexOf()和substring()返回cookie值的部分，再通过unescape()函数进行解码，得到cookie值：</p>

<pre><code> function getCookie(name) {
        var nameEquals =  name + &quot;=&quot;;
        var crumbs = document.cookie.split('; ');
        for (var i = 0; i &lt; crumbs.length; i++) {
            var crumb = crumbs[i];
            if (crumb.indexOf(nameEquals) == 0) {
                return unescape(crumb.substring(nameEquals.length, crumb.length));
            }
        }
        return null;
    }
</code></pre>

<p><strong>注意是<code>var crumbs = document.cookie.split('; ');</code>split()函数的参数是&rsquo;; &lsquo;,在;号之后有个空格。</strong>
测试用程序清单如下：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;jQuery UI测试&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;

    &lt;/style&gt;
    &lt;script&gt;
        function createCookie(name, value, days, path, domain, secure) {
            if (days) {
                var date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                var expires = date.toGMTString();
            }
            else
                var expires = &quot;&quot;;
            var cookieString = name + &quot;=&quot; + escape(value);
            if (expires)
                cookieString += &quot;; expires=&quot; + expires;
            if (path)
                cookieString += &quot;;path =&quot; + escape(path);
            if (domain)
                cookieString += &quot;; domain=&quot; + escape(domain);
            if (secure)
                cookieString += &quot; secure&quot;;
            document.cookie = cookieString;
        }

        createCookie('username', &quot;tom&quot;, 5);
        createCookie('location', &quot;USA&quot;, 5);
        createCookie('status', &quot;fullmember&quot;, 5);

        function getCookie(name) {
            var nameEquals =  name + &quot;=&quot;;
            var crumbs = document.cookie.split('; ');
            for (var i = 0; i &lt; crumbs.length; i++) {
                var crumb = crumbs[i];
                if (crumb.indexOf(nameEquals) == 0) {
                    return unescape(crumb.substring(nameEquals.length, crumb.length));
                }
            }
            return null;
        }

        function btnClick() {
            $(&quot;span&quot;).html(document.cookie);
            var name = $('#input1').val();
            alert(getCookie(name));
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;span&gt;测试用例&lt;/span&gt;&lt;br /&gt;
    &lt;input type=&quot;text&quot; id=&quot;input1&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; onclick=&quot;btnClick()&quot; value=&quot;获取cookie&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="删除-cookie">删除 cookie</h3>

<p>要想删除一个cookies,只需要把它的失效日期设置为今天以前的日期，浏览器就会认为它已经失效了，从而删除它。即使在脚本里删除了cookie,某些浏览器的有些版本也会把cookie维持到重新启动浏览器。如果cookie是否被删除是程序运行的条件，就应该使 用 getCookie来测试被删除的cookie,确保它的确不存在了。</p>

<pre><code>function deleteCookie(name) {
        createCookie(name, &quot;&quot;, -1);
    }
</code></pre>

<p>利用前面介绍的知识，我们来建立一些页面体验cookie操作。首先，把createCookie()、getCookie()和deleteCookie()函数集中到一个JavaScript文件里,保存为cookies.js。
cookies.js程序清单如下：</p>

<pre><code>function createCookie(name, value, days, path, domain, secure) {
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        var expires = date.toGMTString();
    }
    else
        var expires = &quot;&quot;;
    var cookieString = name + &quot;=&quot; + escape(value);
    if (expires)
        cookieString += &quot;; expires=&quot; + expires;
    if (path)
        cookieString += &quot;;path =&quot; + escape(path);
    if (domain)
        cookieString += &quot;; domain=&quot; + escape(domain);
    if (secure)
        cookieString += &quot; secure&quot;;
    document.cookie = cookieString;
}

function getCookie(name) {
    var nameEquals = name + &quot;=&quot;;
    var crumbs = document.cookie.split('; ');
    for (var i = 0; i &lt; crumbs.length; i++) {
        var crumb = crumbs[i];
        if (crumb.indexOf(nameEquals) == 0) {
            return unescape(crumb.substring(nameEquals.length, crumb.length));
        }
    }
    return null;
}

function deleteCookie(name) {
    createCookie(name, &quot;&quot;, -1);
}
</code></pre>

<p>第一个页面cookietest.html程序清单如下：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;测试用例&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;
    &lt;/style&gt;
    &lt;script src=&quot;Resources/cookies.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() { 
            var cookievalue = prompt(&quot;Cookie Value:&quot; ); 
                createCookie(&quot;myCookieData&quot;, cookievalue);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;cookietest2.html&quot;&gt;Go to Cookie Test Page 2&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>第二个页面cookietest2.html程序清单如下：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;测试用例&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;style&gt;
    &lt;/style&gt;
    &lt;script src=&quot;Resources/cookies.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() { 
            var cookievalue = prompt(&quot;Cookie Value:&quot; ); 
                createCookie(&quot;myCookieData&quot;, cookievalue);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;cookietest2.html&quot;&gt;Go to Cookie Test Page 2&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>cookietest.htm1页面输入cookie值，用链接跳转到页面二，页面二在载入的时候将输入的cookie的值显示在页面。</p>

<h3 id="在一个cookie里设置多个值">在一个cookie里设置多个值</h3>

<p>每个cookie包含一对&rdquo;name=value&rdquo;,如果需要保存多个数据，比如用户的姓名、年龄和会员号，就需要三个不同的cookies。然而稍微动一点脑筋，就可以用一个cookie保存这三个值。方法是把需要的值组成一个字符串，让它成为要保存在cookie里的值。通过这种方式，可以避免使用三个单独的cookies,而是只用一个就保存这三部分数据。为了以后分解其中的信息，要在这个字符串里放置特殊字符(所谓的“定界符”)来分隔不同的数据：</p>

<pre><code>var userdata = &quot;Sandy | 26 | A23679&quot;;
createCookie (&quot;user&quot;,userdata);
</code></pre>

<p>这里使用作为定界符。稍后需要读取cookie值时，可以依据它来分割并得到各部分数据：</p>

<pre><code>var myUser = getCookie(&quot;user&quot;); 
var myUserArray = myUser.split('I'); 
var name = myUserArray[0]; 
var age = myUserArray[1]; 
var memNo = myUserArray[2];
</code></pre>

<p>有些浏览器要求cookies的数量不能超过20 ,如果用一个cookie保存多个数值，可以在一定程度上打破这种限制。但是cookies信息总体不能超过4KB是不能改变的。</p>

<p>在使用一个cookie保存多个值时，能否使用任意字符作为定界符？</p>

<p>不能使用可能出现在编码数据里的字符(除非那个字符也当作定界符)，也不能使用等号(=)或分号(;).因为它们用于组成&rdquo;name=value&rdquo;和分隔多对数据。另外，cookies一般不能包含空白和逗号，所以它们也不能当作分界符。</p>

<p>cookies安全吗？</p>

<p>cookies的安全问题经常会被提及，但这种担心大多是没有根据的。cookies能够帮助站长和广告商追踪用户的浏览习惯，他们可以(也的确)利用这些信息在用户访问的页面上有目的地投放广告和提示信息。但是，只使用cookies,他们不能获得用户的个人信息，也不能访问用户计算机硬盘上的其他内容。</p>

<h2 id="javascript新功能">JavaScript新功能</h2>

<h3 id="类">类</h3>

<p>在我们介绍了 OOP,并且介绍了如何创建和操作对象的例子，包括如下这个例子：</p>

<pre><code>function Car(Color, Year, Make, Miles) {
        this.color = Color;
        this.year = Year;
        this.make = Make;
        this.odometerReading = Miles;
        this.setOdometer = function (newMiles) {
            this.odometerReading = newMiles;
        }
    }
</code></pre>

<p>如果你是从其他语言转而学习JavaScript的，你可能已经熟悉了类这个概念了。类是对象的一种表示：</p>

<pre><code>class Car {
        constructor(Color, Year, Make, Miles) { 
            this.color = Color; 
            this.year = Year; 
            this.make = Make; 
            this.odometerReading = Miles;
        }
        setOdometer(newMiles) {
            this.odometerReading = newMiles;
        }
    }
</code></pre>

<p>这一语法也允许你扩展类，从而创建一个新的类以继承其父类的属性。如下面的示例所示：</p>

<pre><code>class Sportscar extends Car { 
        constructor(Color, Year, Make, Miles) { 
            super(Color, Year, Make, Miles); 
            this.doors = 2;
        }
    }
</code></pre>

<p>这里，我们在构造方法中使用了关键字super,以允许调用一个父类的构造方法并继承其所有的属性。实际上，这只是语法糖，就像你在前面所学到的，使用了类的所有内容都可以在函数或原型中覆盖。然而，这种方法使得代码更容易和其他的流行语言兼容，并且也更容易阅读。</p>

<h3 id="箭头函数">箭头函数</h3>

<p>箭头函数(=&gt;)是一个匿名函数的一种简写式的语法</p>

<pre><code>param =&gt; statements or expression
</code></pre>

<p>让我们来进一步说明：</p>

<ul>
<li>param—一个或多个参数的名称。如果该函数没有参数，需要使用()表明。对于只有一个参数的情况，则不需要使用括号。</li>

<li><p>语句或表达式—需要用花括号括起来的多条语句。然而，单个的表达式并不需要花括号。这个表达式也就是该函数的返回值。</p>

<p>var overTen = x=&gt; x &gt; 10 ? 10 : x;
overTen (8) ; // 返回 8
overTen (12) ; // 返回 10</p></li>
</ul>

<p>注意，关键字function并不是必须的，圆括号也可以省略，因为这里只有一个参数。如下的示例有两个参数：</p>

<pre><code>var higher = (x, y) =&gt; { 
         if (x &gt; y) { 
            return x;
         } else { 
            return y;
        }
    }
</code></pre>

<p>也是为了更容易编写，箭头函数还有一项功能，即它们从包含者中继承了this的值。当使用对象的时候，这真的是很方便。而在此之前，我们需要将this赋值给一个变量，从而将其传递到一个函数中，如下所示：</p>

<pre><code>function myObject() {
        this.height = 13;
        var self = this;
        setTimeout(function(){
            console.log(self.height);
        }, 5000)
    }
var o = new myObject ();       
</code></pre>

<p>在前面的例子中，我们不可以直接这样使用：</p>

<pre><code>console.log(this.height);
</code></pre>

<p>因为this将会引用其直接包含者，在这里，就是fiveSecondsLater()函数。然而，通过使 用箭头函数，就可以避免使用self这样的变量：</p>

<pre><code>function myObject() {
        this.height = 13;

        setTimeout(() =&gt; {
            console.log(this.height);
        }, 5000)
    }
var o = new myObject ();      
</code></pre>

<h3 id="模块">模块</h3>

<p>随着JavaScript应用程序变得越来越复杂，需要有一种方法使得在一个文件中声明的对象能够在其他文件中可用。通过这种方法，可以以模块的方式来编写较大的对象。默认情况下，在一个文件中声明的任何内容，在该文件之外都是不可用的。然而在ECMAScript 6 中, 可以使用export关键字使其变得可用。如下是导出一个类的示例：</p>

<pre><code>//这段代码位于filel.js中
export default function Car(Color, Year, Make, Miles) {
    this.color = Color;
    this.year = Year;
    this.make = Make;
    this.odometerReading = Miles;
    this.setOdometer = function (newMiles) {
        this.odometerReading = newMiles;
    }
}
// 这个对象可以由其他的文件导入
</code></pre>

<p>在接收的文件中：</p>

<pre><code>import Car from './file1';
var ferrari = new Car('red', 1981, 'dino', 75500);
</code></pre>

<h3 id="使用let和const">使用let和const</h3>

<p>在ECMAScript6之前，JavaScript只有两类作用域，即函数作用域和全局作用域(我们前面学习过，作用域取决于在代码中的何处使用var关键字来声明变量)。当从其他的语言转而使用JavaScript语言的时候，令众多的开发者沮丧的是，JavaScript缺乏所谓的块作用域，该作用域决定了一个变量只能够在其定义所在的语句块之中访问(块是指一对花括号之中的所有内容)。</p>

<p>新的关键字let允许你声明一个变量，并将其作用域限定为声明它的块、语句或表达式。相反，var关键字定义了一个变量，它要么是全局变量，要么是整个函数中的局部变量， 而不考虑块作用域：</p>

<pre><code>function myFunc() {
    {
        let x;
        if (y == 0) {
            //这没问题，x拥有块作用域
            let x = &quot;inner&quot;;
        }
        //这是个错误，x已经在块中声明过了
        let x = &quot;outer&quot;;
    }
}
</code></pre>

<p>const声明创建一个常量，这是一个只读的、命名的变量。不能使用重新赋值的方式修改一个常量的值，随后也不能重新声明一个常量。使用const关键字声明的值不能够重新初始化、重新声明或重新 赋值。</p>

<pre><code>function myFunc() {
    {
        const x = &quot;foo&quot;;
        //这是个错误，X是一个常量，不能重新定义
        x = &quot;bar&quot;;
    }
}
</code></pre>

<h3 id="模板字符串">模板字符串</h3>

<p>模板字符串帮助构建字符串，它类似于Perl或Python等其他语言中的字符串插值的功能。</p>

<pre><code>var name = &quot;John&quot;;
var course = &quot;Mathematics III&quot;;
var myString = `Hello ${name}, welcome to ${course}.`;
alert(myString);
</code></pre>

<p>也可以替换较为复杂一些的表达式：</p>

<pre><code>var total = 20;
var tax = 4;
msg = 'Total is ${totai} (or ${total + tax}, including tax)';
alert(msg) ; // &quot;Total is 20 (or 24, including tax)&quot;
</code></pre>

<blockquote>
<p>参考<a href="https://blog.csdn.net/zwt_guiji/article/details/81979299">
模板字符串（）的用途</a></p>

<p>模板字符串是在ES6中兴起，个人感觉非常有用：用反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。请看下方截图代码从而可知其模板字符串的强大：
<img src="https://SLTaurus.github.io/images/JavaScript/JavaScript27.jpg" alt="JavaScript27" /></p>

<p>下面代码中，模板字符串都是用反引号表示，如果在模板字符串中需要使用反引号，则前面需要用反斜杠转义。</p>

<pre><code>// 普通字符串
var stringDemo = `In JavaScript '\n' is a line-feed.`
alert(stringDemo);

// 多行字符串
var stringDemo =`In JavaScript this is
not legal.`
alert(stringDemo);

// 字符串中嵌入变量
var name = &quot;Bob&quot;, time = &quot;today&quot;;
var stringDemo = `Hello ${name}, how are you ${time}?`   // Hello Bob, how are you today?
alert(stringDemo);

var greeting = `\`Yo\` World!`; // `Yo` World! 需要用到`的时候需要用反斜杠转义
alert(stringDemo);
</code></pre>

<p>如果使用模板字符串表示多行字符串，则所有的空格、缩进和换行都会被保留在输出中。</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;测试用例&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;script&gt;
        function btnClick() {
            $('#list').html(`
            &lt;ul&gt;
            &lt;li&gt;first&lt;/li&gt;
            &lt;li&gt;second&lt;/li&gt;
            &lt;/ul&gt;
            `);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;list&quot;&gt;&lt;/div&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;btnClick()&quot;&gt;测试用例&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>模板字符串中嵌入变量，要将变量名写在${}之中。大括号内可以放入任意的JavaScript表达式，可以进行运算，以及引入对象属性。</p>

<pre><code>var x = 1, y = 2;
`${x} + ${y} = ${x + y}`;// &quot;1 + 2 = 3&quot;       
`${x} + ${y * 2} = ${x + y * 2}`;// &quot;1 + 4 = 5&quot;
var obj = { x: 1, y: 2 };
`${obj.x + obj.y}`// &quot;3&quot;
</code></pre>

<p>模板字符串之中还可以调用函数。</p>

<pre><code>function func() {
    return 'Hello';
}
alert(`${func()} World`);// &quot;Hello World&quot;
</code></pre>

<p>如果大括号中的值不是字符串，则将按照一般的规则转换为字符串。如，若大括号中是一个对象，则将默认调用对象的toString方法，把对象转换为字符串。如果模板字符串中的变量没有声明，则会报错。</p>

<pre><code>// 变量place没有声明
var msg = `Hello, ${place}`;
// ReferenceError: place is not defined
</code></pre>

<p>模板字符串之间还可以进行嵌套。</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;测试用例&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;script&gt;
        function btnClick() {
            var tmpl = addrs =&gt; `
            &lt;table&gt;
            ${addrs.map(addr =&gt; `
            &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
            `).join('')}
            &lt;/table&gt;
            `;
            alert(tmpl([{ first: 'a', last: 'b' }]));
            $('#list').html(tmpl([{ first: 'a', last: 'b' }]));
        }
        // output:
        /*&quot;
        &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;a&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;b&lt;/td&gt;&lt;/tr&gt;
        &lt;/table&gt;
        &quot;*/
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;list&quot;&gt;&lt;/div&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;btnClick()&quot;&gt;测试用例&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p>

<pre><code>// 写法一
var str = 'return ' + '`Hello ${name}!`';
var func = new Function('name', str);
func('Amy');    // &quot;Hello Amy!&quot;

// 写法二
var str = '(name) =&gt; `Hello ${name}!`';
var func = eval.call(null, str);
func('Amy');    // &quot;Hello Amy!&quot;
</code></pre>

<p>String对象的raw方法:</p>

<p>String.raw方法用来充当模板字符串的处理函数，返回一个除表达式和变量会被替换，其它都保持原样的字符串。String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>

<pre><code>String.raw`Hi\n${2+3}!`;
// &quot;Hi\n5!&quot;
String.raw`Hi\u000A!`;
// &quot;Hi\u000A!&quot;
String.rwa`Hi\\n`;
// &quot;Hi\\n&quot;
</code></pre>

<p><strong>标签模板</strong></p>

<p>模板字符串的功能，不仅是上面那些，它还可以紧跟在一个函数后面，该函数将被调用来处理这个模板字符串，这种称为“标签模板”功能(Tagged template)。标签模板函数第一个参数是字符串模板的常量数组，后面的每一个参数为表达式的计算结果，函数名称可以任意指定。下面是一个例子：</p>

<pre><code>var a = 5, b = 10;
function tag(strings, ...values) {
    console.log(strings[0]);    // &quot;Hello &quot;
    console.log(strings[1]);    // &quot; world&quot;
    console.log(strings[2]);    // &quot;&quot;
    console.log(values[0]);     // 15
    console.log(values[1]);     // 50
    return &quot;Anything&quot;;
}
tag`Hello ${a + b} world ${a * b}`;
// Anything
</code></pre>

<p>标签模板其它是一种特殊的函数调用形式，“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值就是tag函数处理模板字符串后的返回值。函数tag依次会接收到多个参数。tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag函数的其他参数，都是模板字符串各个变量被替换的值。本例中，模板字符串含有两个变量，因此tag会接收到value1和value2两个参数。tag函数所有参数的实际值如下：</p>

<ul>
<li>第一个参数： [‘Hello ‘, ’ world’, ”]</li>
<li>第二个参数: 3</li>
<li>第三个参数： 2</li>
</ul>

<p>也就是说，tag函数实际上是用下面的形式调用：</p>

<pre><code>tag(['Hello ',' world', ''], 3, 2);
</code></pre>
</blockquote>

<h3 id="使用for-of访问数组">使用for-of访问数组</h3>

<p>前面了解到JavaScript拥有各种方法来处理数组。除了 while和 for循环， 还可以使用for-ino遗憾的是，这个循环访问一个数组的所有的命名属性，而不只是实际的数组值：</p>

<pre><code>&quot;use strict&quot;;
let arrl = [6, 5, 7, 9];
arrl.greeting = &quot;hi&quot;;
for (var x in arrl) {
    console.log(x); // 显示&quot;0&quot;, n 1&quot;, &quot;2&quot;, &quot;3n , &quot;greeting&quot;
}
</code></pre>

<p>为了解决这个问题，ECMAScript 6 引入了 for-of构造，它只是遍历属性值：</p>

<pre><code>&quot;use strict&quot;;
let arrl = [6, 5, 7, 9];
arrl.greeting = &quot;hi&quot;;        
for (var y of arrl) {
    console.log(y); // 显示”6”，&quot;5&quot;, ”7&quot;, ”9” 
}
</code></pre>

<p>在代码段的前面使用了&rdquo;use strict&rdquo;指令，该指令是ECMAScript 5 中引入的，表示JavaScript应该以严格模式执行，也就是使用一组较为严格的解释器规则，要使用ECMAScript6 的某些功能，当前必须用这种模式。</p>

<h3 id="小结-3">小结</h3>

<p>我们了解了ECMAScript6规范中将会给JavaScript语言带来的一些重要的新的变化。新的语言功能使得JavaScript的语法和其他的主流语言更加一致，同时也使得代码更加简练和易于阅读。</p>

<h2 id="使用框架">使用框架</h2>

<p>如果你已经编写过很多应用程序，那么你很可能会一次又一次地解决同样的编码问题。能够减少这种重新发明轮子事情的一种技术，就是使用软件框架。在这里，我们将会学习一种流行的网络样式，叫作MVC （Model-View-Controller,模型-视图-控制器）框架，并且介绍如何使用Google的 AngularJS针对单页面的JavaScript应用 程序实现这样一种框架。</p>

<h3 id="软件框架">软件框架</h3>

<p>框架的作用是提高你编写软件应用程序的效率，与此同时，为应用程序增强一致性，提高质量和可靠性以及稳定性。选择编写良好和合适的框架，可以给你节省更多的时间，以便你关注自己的应用程序的 独特需求，而不会在应用程序架构上花费太多的宝贵时间。</p>

<h4 id="为何要使用框架">为何要使用框架</h4>

<p>框架帮助你复用此前已经构建和测试过的代码，提高应用程序的可靠性，减少了在应用程序创建中所需的编码和测试工作。由于框架将结构强加于你的应用程序之上，它还鼓励了更好的编程实践。最后，框架通常为你提供一些方法来扩展其功能，以使得它更加适合于你的应用程序的需求。</p>

<h4 id="框架和库不同">框架和库不同</h4>

<p>很多人把软件框架和软件库这两个术语搞混淆了，然而，框架和库之间有一个基本的区别，当你使用一个库的时候，该库中的对象和方法是已经存在的，等待定制应用程序调用它们。要创建应用程序，你需要知道自己的代码中会用到哪些对象和方法。当使用框架的时候，你自己要设计和编写应用程序所使用的对象和方法。框架只是为你提供一个编写它们的一致的结构。</p>

<h3 id="模型-视图-控制器-mvc-架构">模型-视图-控制器（MVC）架构</h3>

<p>MVC软件架构的概念相当简单：将应用程序分为不同的单元，其中的每一个单元分别属于如下几个部分之一。</p>

<h4 id="模型">模型</h4>

<p>模型表示应用程序中处理业务数据和业务逻辑的部分。模型可能是一个单个的对象，或者它也可以是由各种对象所组成的某些结构。</p>

<h4 id="视图">视图</h4>

<p>视图是用于将信息展现给用户的一个模型的表示。它通常充当一个表现过滤器，只是将一个模型中包含的某些方面的数据展示出来，而隐藏另外一些数据。视图向模型请求，以获取需要表现的数据。它也可以通过发送相应的命令，来修改模型中的数据。这样的查询和命令，都必须在模型中由语意定义。</p>

<h4 id="控制器">控制器</h4>

<p>控制器充当用户和应用程序之间的连接，它安排视图在屏幕上显示，或者通过显示菜单、输入字段、按钮或其他的页面元素来读取用户输入。控制器先解释用户输入，然后将其传递给一个或多个视图。MVC框架的各个部分的运作如下图所示。
<img src="https://SLTaurus.github.io/images/JavaScript/JavaScript28.jpg" alt="JavaScript28" /></p>

<p><strong>真实案例</strong></p>

<p>可以用看电视来比喻一个MVC框架。电视台有各种可用的频道，每个频道包含了不同的数据；这些频道都可以看作是MVC系统中的模型。视图是由电视机的屏幕提供的。你可以使用遙控器（控制器）的功能来和电视机进行交互。</p>

<h3 id="针对webapp使用mvc框架">针对WebAPP使用MVC框架</h3>

<p>MVC架构能够很好地用于Web应用程序中。</p>

<ul>
<li>模型—页面内容存储在支撑应用程序的模型之中。技术性的细节可能有所不同，文本和图像可能存储在数据库中，而服务器文件则以其他的方式存储，但是，数据融合在一起的规则是相同的，都是作为框架的模型部分进行编码的。</li>
<li>视图—HTML和CSS给内容添加了一个或多个可视化的显示层，应用这些层面可以给Web应用程序一种特定的外观和样式。我们可以修改内容显示的方式，而根本不需要修改模型中存储的初始的内容。</li>
<li>控制器—— 控制器元素包含了连接到页面上的交互式元素的程序代码，例如，表单字段、按钮和链接等。这些代码解释用户输入并与模型和视图通信。</li>
</ul>

<h3 id="angularjs-框架">AngularJS 框架</h3>

<p>AngularJS是 Google开发的一个MVC框架，它能够用来构建架构良好的、易于测试的和可维护的JavaScript Web应用程序。它设计来帮助生成强大的、可靠的、单页面的Web应 用程序。</p>

<h4 id="angularjs-概览">AngularJS 概览</h4>

<p>AngularJS是一个MVC框架，它将你的HTML代码 （对应于MVC范型中的视图）和JavaScript对象绑定起来（MVC中的模型部分）。</p>

<p>这样一来，对于模型做出的任何修改，都会自动更新到页面上。反之亦然，例如，当一个文本字段的内容变化的时候，和字段相关联的模型也会更新。同样的方式，视图中的任何修改，例如用户在一个字段输入了信息，或者单击了一个按钮，都会要求修改相应的模型。</p>

<p>在幕后，AngularJS处理了所有这些逻辑，因此，你不必编写代码来更新页面的HTML代码，或者监听并响应用户事件。</p>

<h4 id="在页面中包含angularjs">在页面中包含AngularJS</h4>

<blockquote>
<p><a href="https://www.angularjs.net.cn/download/">AngularJS官方中文网</a></p>
</blockquote>

<p>要使用AngularJS,必须在页面中包含它。最容易的方式就是通过Google的CDN来包含它.AngularJS官网本身采用AngularJS库构建，页面中的AngularJS库通过Google的CDN（内容分发网络）引入，所以国内访问会有问题。国内我们一般推荐是以下CDN.</p>

<p>引入百度CDN:</p>

<pre><code>&lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>bootcdn:</p>

<pre><code>&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>通过上面的引用，你只能使用AngularJS的核心模块,Ng模块。AngularJS还提供了各种功能丰富的模块，如ngRoute，ngAnimate，ngCookies，ngTouch，等等，只要引入相应头文件，在依赖注入你所在的工作模块，则可使用。以下AngularJS个功能模块的CDN，以BootCDN为例。</p>

<p>ngRoute：</p>

<pre><code>&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-route.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-route.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>ngAnimate：</p>

<pre><code>&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-ngAnimate.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-ngAnimate.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>ngRoute：</p>

<pre><code>&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-route.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>ngRoute：</p>

<pre><code>&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-route.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>ngRoute：</p>

<pre><code>&lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular-route.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>通过依赖管理安装</p>

<pre><code>npm
bower
</code></pre>

<h4 id="用ng-指令扩展html">用ng-指令扩展HTML</h4>

<p>AngularJS使用了很多的指令，来帮助你把页面的HTML元素和MVC架构中的模型关联起来。这些指令中的每一个都是以ng-打头的，并且可以添加到任何元素中。</p>

<p>在任何页面中必须包含的关键属性是ng-app,它定义了一个AngularJS应用。你需要将其应用于一个元素，而该元素包含了带有ng-指令的其他页面元素。可以将其应用于页面的<body元素（使得整个页面都成为应用程序的一部分），或者应用于包含应用程序的一个<div>元素：</p>

<pre><code>&lt;body ng-app&gt;
</code></pre>

<p>当页面加载的时候，AngularJS找到这个元素，并且处理在其子元素上所见到的所有ng-指令。</p>

<p>两个更为重要的ng-指令是ng-model和ng-bindo。ng-model指令把输入字段、选择框、文本字段等HTML控件的值和模型中存储的应用程序数据连接起来。ng-bind指令将MVC模型中的应用程序数据绑定到HTML视图中的元素。示例程序清单如下：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;测试用例&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        #output {
            font: 28px bold helvetica, arial, sans-serif;
            color: red;
        }
    &lt;/style&gt;
    &lt;script&gt;

    &lt;/script&gt;
&lt;/head&gt;
&lt;body ng-app&gt;
    &lt;p&gt;Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;
    &lt;span id=Houtput” ng-bind=&quot;name&quot;&gt;&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>只要Web页面加载了，AngularJS就会开始工作。ng-app指令告诉AngularJS,在这个例子中，是页面的<code>&lt;body&gt;</code>元素包含了一个AngularJS应用程序。然后ng-model指令将输入字段中包含的值绑定到变量名称。类似地，ng-bind指令将<code>&lt;span&gt;</code>元素的HTML内容绑定到变量名。通过这种方式，span元素变成了 MVC框架中的一个视图。 现在输入字段中做出的任何修改，都会立即反映到<span>元素中.</p>

<h4 id="作用域">作用域</h4>

<p>作用域是一个对象，它将一个DOM元素（MVC架构中的视图部分）连接到控制器；在MVC的术语中，这个对象变成了模型。</p>

<p>控制器和视图都必须访问作用域模型，因此，作用域可以用于控制器和视图之间的通信。 这个作用域对象将会保存用于视图中的数据和方法。</p>

<p>所有的AngularJS应用程序都有一个$rootScope。这个$rootScope是顶级的作用域，它属于包含了ng-app指令的DOM元素。</p>

<p>当在应用程序中没有设置显式的作用域的时候,SrootScope就是AngularJS用来绑定数据和函数的作用域。前面的示例正是因为这样才能够工作的。</p>

<p>为了更好地了解作用域是如何工作的，让我们将控制器绑定到一个特殊的D0M 元素， 为该元素创建一个作用域，然后与其交互。</p>

<h4 id="指令">指令</h4>

<p>在前面的示例中，我们已经见到过几个指令。在 AngularJS中，指令是连接到一个D0M元素的一个函数，使这个元素能够运行方法、连接到控制器和作用域对象，以及操作DOM。</p>

<p>当一个AngularJS应用程序启动的时候，AngularJS开始遍历DOM（从拥有ng-app属性的DOM元素开始），它将会解析负责收集和运行这些指令的代码。</p>

<p>指令负责实现AngularJS应用程序动态化的所有艰苦工作。我们在前面已经看到过指令的几个示例，包括ng-model和ng-bind指令：</p>

<pre><code>&lt;p&gt;Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;
&lt;span id=Houtput” ng-bind=&quot;name&quot;&gt;&lt;/span&gt;
</code></pre>

<p>AngularJS中还内建了很多默认的指令，我们接下来将会介绍其中的一些。</p>

<h4 id="表达式">表达式</h4>

<p>两对花括号用于包含一个表达式指令：</p>

<pre><code>{{ expression }}
</code></pre>

<p>AngularJS表达式和JavaScript表达式几乎一样，因为它们都包含字面值、操作符和变量。如下都是有效的AngularJS表达式：</p>

<pre><code>{ { 3 + 9 }}
{{ quantity * cost }}
{{ firstName + ” &quot; + lastName }}
</code></pre>

<p>AngularJS表达式在写该表达式的具体位置解释为数字。</p>

<p>ng-init指令在启动的时候运行，在 AngularJS运行任何应用程序代码之前，它就运行了。使用ng-init指令，你可以在运行任何其他函数之前设置默认的变量。</p>

<p>ng-click指令给一个DOM元素添加一个监听器。当单击该元素的时候，AngularJS将执行该指令中定义的表达式。</p>

<p>ng-repeat指令遍历一个集合，并且为每一个项加载一个模板。它所复制的模板，就是拥有ng-repeat属性的元素。</p>

<pre><code>$scope.departments = [
    { name: 'Sales' },
    { name: 'Support'},
    {name: ' Production'}, 
    { name: 'Shipping'}
];
</code></pre>

<p>可以使用ng-repeat来遍历它们：</p>

<pre><code>&lt;body ng-app ng-init=&quot;departments = [
        { name: 'Sales' },
        { name: 'Support'},
        {name: ' Production'}, 
        { name: 'Shipping'}];&quot;&gt;
 &lt;ul&gt;
     &lt;li ng-repeat=&quot;dept in departments&quot;&gt;{{dept.name }}&lt;/li&gt;
 &lt;/ul&gt;
&lt;/body&gt;
</code></pre>

<p>这里的<li>元素将会复制4 次，以得到发送给视图的列表。</p>

<h4 id="过滤器">过滤器</h4>

<p>过滤器的工作就是从数组中选择元素的一个子集，并且将其当作一个新的数组返回。如下是能够对一个数组做的一些事情：</p>

<ul>
<li>使用currency,将一个数字格式化为货币的格式。</li>
<li>使用filter,从数组中选择元素的一个子集。</li>
<li>使用lowercase,将一个字符串格式化为小写的。</li>
<li>使用orderBy,根据一个表达式来排序数组。</li>
<li>使用uppercase,将一个字符串格式化为大写的。</li>
</ul>

<p>如下是AngularJS中一个过滤器的一般语法：</p>

<pre><code>{{filter_expression | filter:expression:comparator}}
</code></pre>

<p>下面示例中，将会计算表达式{{netTotal + tax } } ,并且结果将会格式化为货币。</p>

<pre><code>&lt;div ng-app&gt;
    Total: &lt;input type=&quot;number&quot; ng-model=&quot;netTotal&quot;&gt;
    Tax: &lt;input type=&quot;number&quot; ng-model=&quot;tax&quot;&gt;
    &lt;p&gt;Invoice Total = {{netTotal + tax | currency}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>也可以给任何ng-指令添加一个过滤器，只要使用管道符号(|),后面跟着一个过滤器的说明就可以了：</p>

<pre><code>&lt;ul&gt;
    &lt;li ng-repeat=&quot;dept in departments | filter: uppercase&quot;&gt;{{ dept.name }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h3 id="构建一个angularjs应用程序">构建一个AngularJS应用程序</h3>

<p>现在，我们将所有的知识综合应用，来构建一个基本的AngularJS应用程序。我们先从一个基本的HTML页面开始，它包含一个文本输入字段，用来接收用户输入的搜索字符串，还有一个<code>&lt;div&gt;</code>元素，用来包含带有输入的字符串的搜索结果的一个列表。下面代码中，模板字符串都是用反引号表示，如果在模板字符串中需要使用反引号，则前面需要用反斜杠转义。</p>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;测试用例&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.10.4/themes/start/jquery-ui.css&quot;&gt;
    &lt;script src=&quot;//code.jquery.com/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//code.jquery.com/ui/1.10.4/jquery-ui.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://jqueryui.com/resources/demos/style.css&quot;&gt;
    &lt;script src=&quot;//cdn.bootcss.com/angular.js/1.5.8/angular.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            background-color: #ddf;
            font: 16px bold helvetica, arial, sans-serif;
        }
        input {
            padding: 10px;
        }
        #list-container {
            background-color: white;
            color: #448;
            border-radius: 25px;
            border：1px solid black;
            padding: 25px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body ng-app ng-init=&quot;departments = [
    { name: 'Sales',contact: 'Marsha Brown'},
    { name: 'Support',contact: 'Dave Price'},
    { name: 'Production',contact: 'Grant Wales'},
    { name: 'Service',contact: ' Sherry Dell'},
    { name: 'Administration',contact: 'Sally Bennett'},
    { name: 'Accounting',contact: 'Kim Sutherland'},
    { name: 'Shipping',contact: ' Sandy Connell'}]&quot;&gt;
    &lt;p&gt;Search Departments: &lt;input type=&quot;text&quot; placeholder=&quot;Enter search string&quot; ng-model=&quot;searchString&quot;&gt;&lt;/p&gt;
    &lt;div id=&quot;list-container&quot;&gt;
        &lt;ul&gt;
            &lt;li ng-repeat=&quot;dept in departments | filter: searchString&quot;&gt;{{dept.name + &quot;(&quot; + dept.contact + &quot;)&quot;}}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>我们对页面应用必要的ng-指令：</p>

<p>对<code>&lt;body&gt;</code>元素应用<code>ng-app</code>指令，将该元素定义为这个AngularJS应用程序的容器。对搜索字段应用ng-model指令，将其定义为MVC框架中的一个模型。对搜索结果的列表中的<code>&lt;li&gt;</code>元素应用<code>ng-repeat</code>指令。<code>&lt;li&gt;</code>元素将会对于每个搜索结果都重复一次。我们还使用了<code>ng-init</code>指令来为应用程序设置一些初始数据。在真实的情况中，这一数据更可能是从诸如服务器端数据库这样的外部来源引入的，但在这里，只是为了充当示例。</p>

<p>这就是我们需要做的所有事情! AngularJS负责处理数据绑定，以便当用户输入数据的时候，过滤器能真正地起作用.</p>

<h3 id="小结-4">小结</h3>

<p>我们学习了模型-视图-控制器框架架构的基础知识，并介绍了如何将其应用于Web应用程序。我们还学习了Google的AngularJS框架，并且添加少量代码甚至不添加代码，就使用它构建了一个简单的Web应用。 实际上，对于AngularJS所能做的事情，我们也只是浅尝辄止。不妨访问AngularJS的官方网站<a href="https://www.angularjs.net.cn/以学习更多内容。">https://www.angularjs.net.cn/以学习更多内容。</a></p>

<h2 id="web页面之外的javascript">Web页面之外的JavaScript</h2>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://SLTaurus.github.io/tags/javascript/">JavaScript</a>

                  </div>
                
              
            
			
			  
  <span id="/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/" class="leancloud_visitors" data-flag-title="JavaScript入门经典第6版笔记(下)">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">100</span>
    <p></p>
  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'qmkacTy81gjW31F1mPV0T8UP-gzGzoHsz',
        appKey: '27rweMzy4Q07Rqa7s4RKVD8O',
        notify:  false , 
        verify:  false , 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://SLTaurus.github.io/2019/08/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A/" data-tooltip="JavaScript入门经典第6版笔记(上)">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--disabled">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 <a href="https://github.com/SLTaurus">轲</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://SLTaurus.github.io/2019/08/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A/" data-tooltip="JavaScript入门经典第6版笔记(上)">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--disabled">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://SLTaurus.github.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2FSLTaurus.github.io%2F2019%2F09%2Fjavascript%25E5%2585%25A5%25E9%2597%25A8%25E7%25BB%258F%25E5%2585%25B8%25E7%25AC%25AC6%25E7%2589%2588%25E7%25AC%2594%25E8%25AE%25B0%25E4%25B8%258B%2F">
          <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2FSLTaurus.github.io%2F2019%2F09%2Fjavascript%25E5%2585%25A5%25E9%2597%25A8%25E7%25BB%258F%25E5%2585%25B8%25E7%25AC%25AC6%25E7%2589%2588%25E7%25AC%2594%25E8%25AE%25B0%25E4%25B8%258B%2F">
          <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2FSLTaurus.github.io%2F2019%2F09%2Fjavascript%25E5%2585%25A5%25E9%2597%25A8%25E7%25BB%258F%25E5%2585%25B8%25E7%25AC%25AC6%25E7%2589%2588%25E7%25AC%2594%25E8%25AE%25B0%25E4%25B8%258B%2F">
          <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://SLTaurus.github.io/images/touxiang.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">轲</h4>
    
      <div id="about-card-bio">只要坚持希望不气馁，生活迟早会让我们变得无所不能。</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        程序猿
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        广州
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://SLTaurus.github.io/images/cover.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://SLTaurus.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


  
    <script src="https://SLTaurus.github.io/js/myscript.js"></script>
  

<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/SLTaurus.github.io\/2019\/09\/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B\/';
          
            this.page.identifier = '\/2019\/09\/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

